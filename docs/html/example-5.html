<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>UltraCold: example-5</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/SVG"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">UltraCold
   </div>
   <div id="projectbrief">Collection of C++ libraries for the study of ultra-cold systems in the context of Gross-Pitaevskii theory</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('example-5.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">example-5 </div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#Title-5">Simple dynamics of two vortices in a two-dimensional dipolar Bose gas, using GPU acceleration.</a><ul><li class="level2"><a href="#Introduction-5">Introduction</a></li>
<li class="level2"><a href="#What-5">Program description</a></li>
<li class="level2"><a href="#Results-5">Results</a></li>
<li class="level2"><a href="#Uncommented-5">The plain program</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><dl class="section author"><dt>Author</dt><dd>Santo Maria Roccuzzo (<a href="#" onclick="location.href='mai'+'lto:'+'san'+'to'+'m.r'+'oc'+'cuz'+'zo'+'@gm'+'ai'+'l.c'+'om'; return false;">santo<span class="obfuscator">.nosp@m.</span>m.ro<span class="obfuscator">.nosp@m.</span>ccuzz<span class="obfuscator">.nosp@m.</span>o@gm<span class="obfuscator">.nosp@m.</span>ail.c<span class="obfuscator">.nosp@m.</span>om</a>)</dd></dl>
<h1><a class="anchor" id="Title-5"></a>
Simple dynamics of two vortices in a two-dimensional dipolar Bose gas, using GPU acceleration.</h1>
<h2><a class="anchor" id="Introduction-5"></a>
Introduction</h2>
<p >In this example, we are going to see how to use NVIDIA GPUs to accelerate the Gross-Pitaevskii solvers available in <a class="el" href="namespace_ultra_cold.html" title="All the classes and functions necessary to work with UltraCold.">UltraCold</a>. A program using GPU accelerated <a class="el" href="namespace_ultra_cold.html" title="All the classes and functions necessary to work with UltraCold.">UltraCold</a> solvers is practically identical to one using only cpus, with only two important differences</p>
<ul>
<li>All GPU-accelerated Gross-Pitaevskii solvers belong to the <code>cudaSolvers</code> namespace. Hence, to declare one such solver, the syntax is, for example <code> cudaSolvers::DipolarGPSolver </code>.</li>
<li>In the CMakeLists.txt file, we have to specify that the programming languages used are both c++ and CUDA, i.e. we have a line like <div class="fragment"><div class="line">project(example-5 LANGUAGES CXX CUDA)</div>
</div><!-- fragment --> and, also, we need to use the macro ULTRACOLD_SETUP_TARGET_WITH_CUDA. See the CMakeLists.txt file in the folder example-5 for details.</li>
</ul>
<p >The physics problem we are going to tackle is rather simple, namely the dynamics of two vortices in a two-dimensional dipolar Bose gas, with the dipoles eventually tilted with respect to the simulation plain (in our case, the x-y plain). In practice, we reproduce some simple results from <a href="https://arxiv.org/pdf/1310.3640.pdf">this paper </a> (see, in particular, figure 5b).</p>
<h2><a class="anchor" id="What-5"></a>
Program description</h2>
<p >As always, we first create an input file containing our mesh and physical parameters, as well as other parameters determining the run-time behavior of the system. Such input file will be called <code>example-5.prm</code> and contain the following text</p>
<pre class="fragment"># Mesh parameters

xmax = 20 # Size of the mesh along the x-axis, in micrometers. The mesh will extend from -xmax to xmax
ymax = 20 # Size of the mesh along the y-axis, in micrometers. The mesh will extend from -ymax to ymax

nx = 512 # Number of points along the x-axis
ny = 512 # Number of points along the y-axis

omegaz = 1000

# Physical parameters

scattering length   = 110.0  # Scattering length in units of the Bohr radius
dipolar    length   = 132.0  # Dipolar length in units of the Bohr radius
number of particles = 80000  # Total number of atoms
atomic mass         = 164    # Atomic mass, in atomic mass units
theta = 0.78 # tilt angle in radiant

# Run parameters for gradient descent

number of gradient descent steps = 5000 # maximum number of gradient descent steps
residual                         = 1.E-12 # Threshold on the norm of the residual
alpha                            = 1.E-4 # gradient descent step
beta                             = 0.9   # step for the heavy-ball acceleration method

# Run parameters for real-time dynamics

number of real time steps = 5000 # Total number of time-steps for real time dynamics
time step                 = 0.001 # Time step for real-time dynamics, in milliseconds</pre><p >In the source file, we then create a custom solver for a dipolar Gross-Pitaevskii equation in two space dimensions, overriding the function that writes the output at each (few) time steps in order to write, as usual, a .vtk file containing the wave function.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span><a class="code hl_class" href="class_dipoles2d.html">Dipoles2d</a> : <span class="keyword">public</span> cudaSolvers::DipolarGPSolver</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">using </span>DipolarGPSolver::DipolarGPSolver;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> <a class="code hl_function" href="class_dipoles2d.html#a7a3362455056efb1e51dc2caad00fdaa">write_operator_splitting_output</a>(<span class="keywordtype">size_t</span> iteration_number,</div>
<div class="line">                                         std::ostream&amp; output_stream) <span class="keyword">override</span>;</div>
<div class="line"> </div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="class_dipoles2d.html#a7a3362455056efb1e51dc2caad00fdaa">Dipoles2d::write_operator_splitting_output</a>(<span class="keywordtype">size_t</span> iteration_number,</div>
<div class="line">                                                std::ostream &amp;output_stream)</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span>(iteration_number % write_output_every == 0)</div>
<div class="line">    {</div>
<div class="line"> </div>
<div class="line">        GraphicOutput::DataWriter data_out;</div>
<div class="line">        data_out.set_output_name(<span class="stringliteral">&quot;psi&quot;</span>+std::to_string(iteration_number));</div>
<div class="line">        data_out.write_vtk(x_axis,y_axis,wave_function_output,<span class="stringliteral">&quot;psi&quot;</span>,<span class="stringliteral">&quot;ASCII&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aclass_dipoles2d_html"><div class="ttname"><a href="class_dipoles2d.html">Dipoles2d</a></div><div class="ttdef"><b>Definition:</b> example-5.cpp:30</div></div>
<div class="ttc" id="aclass_dipoles2d_html_a7a3362455056efb1e51dc2caad00fdaa"><div class="ttname"><a href="class_dipoles2d.html#a7a3362455056efb1e51dc2caad00fdaa">Dipoles2d::write_operator_splitting_output</a></div><div class="ttdeci">void write_operator_splitting_output(size_t iteration_number, std::ostream &amp;output_stream) override</div><div class="ttdoc">Operator splitting output.</div><div class="ttdef"><b>Definition:</b> example-5.cpp:40</div></div>
</div><!-- fragment --><p >We then read the input file using the class <code> Tools::InputParser </code>, set harmonic units (imagining that the system is in a quasi-two-dimensional setup due to a strong harmonic confinement along the z-axis) and create a mesh.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line"> </div>
<div class="line">    Tools::InputParser ip(<span class="stringliteral">&quot;example-5.prm&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    ip.read_input_file();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> xmax = ip.retrieve_double(<span class="stringliteral">&quot;xmax&quot;</span>);</div>
<div class="line">    <span class="keywordtype">double</span> ymax = ip.retrieve_double(<span class="stringliteral">&quot;ymax&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> nx = ip.retrieve_int(<span class="stringliteral">&quot;nx&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> ny = ip.retrieve_int(<span class="stringliteral">&quot;ny&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> scattering_length = ip.retrieve_double(<span class="stringliteral">&quot;scattering length&quot;</span>);</div>
<div class="line">    <span class="keywordtype">double</span> dipolar_length    = ip.retrieve_double(<span class="stringliteral">&quot;dipolar length&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span>    number_of_particles = ip.retrieve_int(<span class="stringliteral">&quot;number of particles&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> atomic_mass         = ip.retrieve_double(<span class="stringliteral">&quot;atomic mass&quot;</span>);</div>
<div class="line">    <span class="keywordtype">double</span> omegaz                    = ip.retrieve_double(<span class="stringliteral">&quot;omegaz&quot;</span>);</div>
<div class="line">    <span class="keywordtype">double</span> theta = ip.retrieve_double(<span class="stringliteral">&quot;theta&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span>    number_of_gradient_descent_steps = ip.retrieve_int(<span class="stringliteral">&quot;number of gradient descent steps&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> alpha                            = ip.retrieve_double(<span class="stringliteral">&quot;alpha&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> beta                             = ip.retrieve_double(<span class="stringliteral">&quot;beta&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> write_output_every=ip.retrieve_int(<span class="stringliteral">&quot;write output every&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span>    number_of_real_time_steps = ip.retrieve_int(<span class="stringliteral">&quot;number of real time steps&quot;</span>);</div>
<div class="line">    <span class="keywordtype">double</span> time_step                       = ip.retrieve_double(<span class="stringliteral">&quot;time step&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// These two constants are for fixing the units</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> hbar        = 0.6347*1.E5; <span class="comment">// hbar in amu*mum^2/s</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> bohr_radius = 5.292E-5;    <span class="comment">// bohr radius in mum</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Lengths are measured in units of the harmonic oscillator length along the z-axis, times as 1/(2 PI omega_z)</span></div>
<div class="line">    omegaz *= TWOPI;</div>
<div class="line">    time_step     = time_step*omegaz/1000.0;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> a_ho = std::sqrt(hbar/(atomic_mass*(omegaz)));</div>
<div class="line"> </div>
<div class="line">    scattering_length *= bohr_radius/a_ho;</div>
<div class="line">    dipolar_length    *= bohr_radius/a_ho;</div>
<div class="line"> </div>
<div class="line">    xmax = xmax/a_ho;</div>
<div class="line">    ymax = ymax/a_ho;</div>
<div class="line">    Vector&lt;double&gt; x(nx);</div>
<div class="line">    Vector&lt;double&gt; y(ny);</div>
<div class="line">    <span class="keywordtype">double</span> dx = 2.*xmax/nx;</div>
<div class="line">    <span class="keywordtype">double</span> dy = 2.*ymax/ny;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; nx; ++i) x(i) = -xmax + i*dx;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; ny; ++i) y(i) = -ymax + i*dy;</div>
<div class="line">    <span class="keywordtype">double</span> dv = dx*dy;</div>
</div><!-- fragment --><p >Then, we set the initial wave function and external potential for the calculation of the stationary state of the system.</p>
<p >Here, we must be rather careful. The typical procedure for the phase imprint of a vortex in a Gross-Pitaevskii simulation is to multiply an initial wave function (for example, the ground state in a harmonic oscillator trap) with the desired phase pattern (in the simplest case, a simple factor \( e^{i\theta} \)), and then evolve the equation for just a few steps in imaginary time (or gradient descent). However, in the absence of trapping (as the case we are considering here) this procedure imprints vortices also at the boundaries, due to the non-matching of the imprinted phases at the boundaries between our wave function and its repeated periodic copies. In order to overcome this problem, one typical procedure is to restrict the physical domain into only one-fourth of the simulation mesh, and to imprint appropriately other (non-physical) vortices and anti-vortices in such a way that the phase at the boundaries of the physical domain is zero. Here, we choose, as our physical domain, the quadrant with boundaries \( [0,x_{max}] \) along the x-axis and \( [0,y_{max}] \) along the y-axis. Choosing then a point \( (x_1,y_1) \) into this quadrant, we also need to imprint anti-vortices at \( (-x_1,y_1) \) and \( (x_1,-y_1) \), and a vortex at \( (-x_1,-y_1) \). This is exactly what is done in the next lines, where we imprint two vortices in the physical domain and the corresponding vortex and anti-vortices in the other quadrants:</p>
<div class="fragment"><div class="line">    <span class="keywordtype">double</span> x_vortex1=-1/a_ho+xmax/2;</div>
<div class="line">    <span class="keywordtype">double</span> y_vortex1=0./a_ho+ymax/2;</div>
<div class="line">    <span class="keywordtype">double</span> x_vortex2=1./a_ho+xmax/2;</div>
<div class="line">    <span class="keywordtype">double</span> y_vortex2=0./a_ho+ymax/2;</div>
<div class="line">    <span class="keywordtype">double</span> phase;</div>
<div class="line"> </div>
<div class="line">    std::complex&lt;double&gt; ci={0.0,1.0};</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; nx; ++i)</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; ny; ++j)</div>
<div class="line">        {</div>
<div class="line"> </div>
<div class="line">            psi(i,j) = sqrt(density);</div>
<div class="line"> </div>
<div class="line">            <span class="comment">// Imprint a vortex at x1,y1</span></div>
<div class="line">            phase=atan2(y(j)-y_vortex1,x(i)-x_vortex1);</div>
<div class="line">            psi(i,j) *= sqrt_density*exp(ci*phase);</div>
<div class="line"> </div>
<div class="line">            <span class="comment">// Imprint the corresponding anti-vortices at -x1,y1 and x1,-y1, and a vortex at -x1, -y1</span></div>
<div class="line"> </div>
<div class="line">            <span class="comment">// -x1,y1</span></div>
<div class="line">            phase=atan2(y(j)-y_vortex1,x(i)+x_vortex1);</div>
<div class="line">            psi(i,j) *= sqrt_density*exp(-ci*phase);</div>
<div class="line"> </div>
<div class="line">            <span class="comment">// x1,-y1</span></div>
<div class="line">            phase=atan2(y(j)+y_vortex1,x(i)-x_vortex1);</div>
<div class="line">            psi(i,j) *= sqrt_density*exp(-ci*phase);</div>
<div class="line"> </div>
<div class="line">            <span class="comment">// -x1,-y1</span></div>
<div class="line">            phase=atan2(y(j)+y_vortex1,x(i)+x_vortex1);</div>
<div class="line">            psi(i,j) *= sqrt_density*exp(ci*phase);</div>
<div class="line"> </div>
<div class="line">            <span class="comment">// Now the same at x2,y2</span></div>
<div class="line"> </div>
<div class="line">            phase=atan2(y(j)-y_vortex2,x(i)-x_vortex2);</div>
<div class="line">            psi(i,j) *= sqrt_density*exp(ci*phase);</div>
<div class="line"> </div>
<div class="line">            <span class="comment">// -x2,y2</span></div>
<div class="line">            phase=atan2(y(j)-y_vortex2,x(i)+x_vortex2);</div>
<div class="line">            psi(i,j) *= sqrt_density*exp(-ci*phase);</div>
<div class="line"> </div>
<div class="line">            <span class="comment">// x2,-y2</span></div>
<div class="line">            phase=atan2(y(j)+y_vortex2,x(i)-x_vortex2);</div>
<div class="line">            psi(i,j) *= sqrt_density*exp(-ci*phase);</div>
<div class="line"> </div>
<div class="line">            <span class="comment">// -x2,-y2</span></div>
<div class="line">            phase=atan2(y(j)+y_vortex2,x(i)+x_vortex2);</div>
<div class="line">            psi(i,j) *= sqrt_density*exp(ci*phase);</div>
<div class="line"> </div>
<div class="line">            <span class="comment">// Uncomment if you want to initialize a hard-wall box at the boundaries,</span></div>
<div class="line">            <span class="comment">// or to set the external potential that you want</span></div>
<div class="line"><span class="comment">//            if(i == 0 || j == 0 || i == nx-1 || j == ny-1 )</span></div>
<div class="line"><span class="comment">//                Vext(i,j) = 100;</span></div>
<div class="line">        }</div>
</div><!-- fragment --><p >We next normalize the wave function, and declare our solver class</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> norm = 0.0;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; psi.size(); ++i) norm += std::norm(psi[i]);</div>
<div class="line">norm *= dv;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; psi.size(); ++i) psi[i] *= std::sqrt(number_of_particles/norm);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="class_dipoles2d.html">Dipoles2d</a> gp_solver(x,y,psi,Vext,scattering_length,dipolar_length,theta);</div>
</div><!-- fragment --><p >and make some gradient descent step until the vortices are formed. Note that, for CUDA solvers, no residual is calculated (for brutal performance reasons)</p>
<div class="fragment"><div class="line">std::fstream gradient_descent_output_stream;</div>
<div class="line">gradient_descent_output_stream.open(<span class="stringliteral">&quot;gradient_descent_output.csv&quot;</span>,std::ios::out);</div>
<div class="line"><span class="keywordtype">double</span> chemical_potential;</div>
<div class="line">std::tie(psi,chemical_potential) = gp_solver.run_gradient_descent(number_of_gradient_descent_steps,</div>
<div class="line">                                                                  alpha,</div>
<div class="line">                                                                  beta,</div>
<div class="line">                                                                  std::cout,</div>
<div class="line">                                                                  write_output_every);</div>
<div class="line"> </div>
<div class="line">gradient_descent_output_stream.close();</div>
</div><!-- fragment --><p >and, finally, reinitialize the solver and run the real-time simulation</p>
<div class="fragment"><div class="line">    gp_solver.reinit(Vext,psi);</div>
<div class="line">    gp_solver.run_operator_splitting(number_of_real_time_steps,time_step,std::cout,write_output_every);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p >As you can see, the syntax is practically identical to the one of non-CUDA solvers, since all the details of the GPU implementation are hidden inside the solver classes.</p>
<h2><a class="anchor" id="Results-5"></a>
Results</h2>
<p >After our few gradient descent iterations, our initial density profile in the physical domain look like this</p>
<div class="image">
<img src="example-5-time0.png" alt=""/>
</div>
<p >While this is how the real-time evolution looks like</p>
<div class="image">
<img src="example-5-time-evolution.png" alt=""/>
</div>
<h2><a class="anchor" id="Uncommented-5"></a>
The plain program</h2>
<div class="fragment"><div class="line"><span class="comment">/*--------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> *    This file is part of the UltraCold project.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> *    UltraCold is free software: you can redistribute it and/or modify</span></div>
<div class="line"><span class="comment"> *    it under the terms of the GNU General Public License as published by</span></div>
<div class="line"><span class="comment"> *    the Free Software Foundation, either version 3 of the License, or</span></div>
<div class="line"><span class="comment"> *    any later version.</span></div>
<div class="line"><span class="comment"> *    UltraCold is distributed in the hope that it will be useful,</span></div>
<div class="line"><span class="comment"> *    but WITHOUT ANY WARRANTY; without even the implied warranty of</span></div>
<div class="line"><span class="comment"> *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span></div>
<div class="line"><span class="comment"> *    GNU General Public License for more details.</span></div>
<div class="line"><span class="comment"> *    You should have received a copy of the GNU General Public License</span></div>
<div class="line"><span class="comment"> *    along with UltraCold.  If not, see &lt;https://www.gnu.org/licenses/&gt;.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> *--------------------------------------------------------------------------------*/</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;UltraCold.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespace_ultra_cold.html">UltraCold</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span><a class="code hl_class" href="class_dipoles2d.html">Dipoles2d</a> : <span class="keyword">public</span> <a class="code hl_class" href="class_ultra_cold_1_1cuda_solvers_1_1_dipolar_g_p_solver.html">cudaSolvers::DipolarGPSolver</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">using </span>DipolarGPSolver::DipolarGPSolver;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> <a class="code hl_function" href="class_dipoles2d.html#a7a3362455056efb1e51dc2caad00fdaa">write_operator_splitting_output</a>(<span class="keywordtype">size_t</span> iteration_number,</div>
<div class="line">                                         std::ostream&amp; output_stream) <span class="keyword">override</span>;</div>
<div class="line"> </div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="class_dipoles2d.html#a7a3362455056efb1e51dc2caad00fdaa">Dipoles2d::write_operator_splitting_output</a>(<span class="keywordtype">size_t</span> iteration_number,</div>
<div class="line">                                                std::ostream &amp;output_stream)</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span>(iteration_number % write_output_every == 0)</div>
<div class="line">    {</div>
<div class="line"> </div>
<div class="line">        <a class="code hl_class" href="class_ultra_cold_1_1_graphic_output_1_1_data_writer.html">GraphicOutput::DataWriter</a> data_out;</div>
<div class="line">        data_out.<a class="code hl_function" href="class_ultra_cold_1_1_graphic_output_1_1_data_writer.html#a5379ac7b98c084855b372e863c095856">set_output_name</a>(<span class="stringliteral">&quot;psi&quot;</span>+std::to_string(iteration_number));</div>
<div class="line">        data_out.<a class="code hl_function" href="class_ultra_cold_1_1_graphic_output_1_1_data_writer.html#aec73552d1a4ccd5f3111c6268961279b">write_vtk</a>(x_axis,y_axis,wave_function_output,<span class="stringliteral">&quot;psi&quot;</span>,<span class="stringliteral">&quot;ASCII&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_ultra_cold_1_1_tools_1_1_input_parser.html">Tools::InputParser</a> ip(<span class="stringliteral">&quot;example-5.prm&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    ip.read_input_file();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> xmax = ip.retrieve_double(<span class="stringliteral">&quot;xmax&quot;</span>);</div>
<div class="line">    <span class="keywordtype">double</span> ymax = ip.retrieve_double(<span class="stringliteral">&quot;ymax&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> nx = ip.retrieve_int(<span class="stringliteral">&quot;nx&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> ny = ip.retrieve_int(<span class="stringliteral">&quot;ny&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> scattering_length = ip.retrieve_double(<span class="stringliteral">&quot;scattering length&quot;</span>);</div>
<div class="line">    <span class="keywordtype">double</span> dipolar_length    = ip.retrieve_double(<span class="stringliteral">&quot;dipolar length&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span>    number_of_particles = ip.retrieve_int(<span class="stringliteral">&quot;number of particles&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> atomic_mass         = ip.retrieve_double(<span class="stringliteral">&quot;atomic mass&quot;</span>);</div>
<div class="line">    <span class="keywordtype">double</span> omegaz                    = ip.retrieve_double(<span class="stringliteral">&quot;omegaz&quot;</span>);</div>
<div class="line">    <span class="keywordtype">double</span> theta = ip.retrieve_double(<span class="stringliteral">&quot;theta&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span>    number_of_gradient_descent_steps = ip.retrieve_int(<span class="stringliteral">&quot;number of gradient descent steps&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> alpha                            = ip.retrieve_double(<span class="stringliteral">&quot;alpha&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> beta                             = ip.retrieve_double(<span class="stringliteral">&quot;beta&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> write_output_every=ip.retrieve_int(<span class="stringliteral">&quot;write output every&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span>    number_of_real_time_steps = ip.retrieve_int(<span class="stringliteral">&quot;number of real time steps&quot;</span>);</div>
<div class="line">    <span class="keywordtype">double</span> time_step                       = ip.retrieve_double(<span class="stringliteral">&quot;time step&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// These two constants are for fixing the units</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> hbar        = 0.6347*1.E5; <span class="comment">// hbar in amu*mum^2/s</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> bohr_radius = 5.292E-5;    <span class="comment">// bohr radius in mum</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Lengths are measured in units of the harmonic oscillator length along the z-axis, times as 1/(2 PI omega_z)</span></div>
<div class="line">    omegaz *= TWOPI;</div>
<div class="line">    time_step     = time_step*omegaz/1000.0;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> a_ho = std::sqrt(hbar/(atomic_mass*(omegaz)));</div>
<div class="line"> </div>
<div class="line">    scattering_length *= bohr_radius/a_ho;</div>
<div class="line">    dipolar_length    *= bohr_radius/a_ho;</div>
<div class="line"> </div>
<div class="line">    xmax = xmax/a_ho;</div>
<div class="line">    ymax = ymax/a_ho;</div>
<div class="line">    <a class="code hl_class" href="class_ultra_cold_1_1_vector.html">Vector&lt;double&gt;</a> x(nx);</div>
<div class="line">    <a class="code hl_class" href="class_ultra_cold_1_1_vector.html">Vector&lt;double&gt;</a> y(ny);</div>
<div class="line">    <span class="keywordtype">double</span> dx = 2.*xmax/nx;</div>
<div class="line">    <span class="keywordtype">double</span> dy = 2.*ymax/ny;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; nx; ++i) x(i) = -xmax + i*dx;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; ny; ++i) y(i) = -ymax + i*dy;</div>
<div class="line">    <span class="keywordtype">double</span> dv = dx*dy;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> density = number_of_particles/(4*xmax*ymax);</div>
<div class="line">    <span class="keywordtype">double</span> sqrt_density=std::sqrt(density);</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_ultra_cold_1_1_vector.html">Vector&lt;std::complex&lt;double&gt;</a>&gt; psi(nx,ny),psitilde(nx,ny);</div>
<div class="line">    <a class="code hl_class" href="class_ultra_cold_1_1_vector.html">Vector&lt;double&gt;</a> Vext(nx,ny);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> x_vortex1=-1/a_ho+xmax/2;</div>
<div class="line">    <span class="keywordtype">double</span> y_vortex1=0./a_ho+ymax/2;</div>
<div class="line">    <span class="keywordtype">double</span> x_vortex2=1./a_ho+xmax/2;</div>
<div class="line">    <span class="keywordtype">double</span> y_vortex2=0./a_ho+ymax/2;</div>
<div class="line">    <span class="keywordtype">double</span> phase;</div>
<div class="line"> </div>
<div class="line">    std::complex&lt;double&gt; ci={0.0,1.0};</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; nx; ++i)</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; ny; ++j)</div>
<div class="line">        {</div>
<div class="line"> </div>
<div class="line">            psi(i,j) = sqrt(density);</div>
<div class="line"> </div>
<div class="line">            <span class="comment">// Imprint a vortex at x1,y1</span></div>
<div class="line">            phase=atan2(y(j)-y_vortex1,x(i)-x_vortex1);</div>
<div class="line">            psi(i,j) *= sqrt_density*exp(ci*phase);</div>
<div class="line"> </div>
<div class="line">            <span class="comment">// Imprint the corresponding anti-vortices at -x1,y1 and x1,-y1, and a vortex at -x1, -y1</span></div>
<div class="line"> </div>
<div class="line">            <span class="comment">// -x1,y1</span></div>
<div class="line">            phase=atan2(y(j)-y_vortex1,x(i)+x_vortex1);</div>
<div class="line">            psi(i,j) *= sqrt_density*exp(-ci*phase);</div>
<div class="line"> </div>
<div class="line">            <span class="comment">// x1,-y1</span></div>
<div class="line">            phase=atan2(y(j)+y_vortex1,x(i)-x_vortex1);</div>
<div class="line">            psi(i,j) *= sqrt_density*exp(-ci*phase);</div>
<div class="line"> </div>
<div class="line">            <span class="comment">// -x1,-y1</span></div>
<div class="line">            phase=atan2(y(j)+y_vortex1,x(i)+x_vortex1);</div>
<div class="line">            psi(i,j) *= sqrt_density*exp(ci*phase);</div>
<div class="line"> </div>
<div class="line">            <span class="comment">// Now the same at x2,y2</span></div>
<div class="line"> </div>
<div class="line">            phase=atan2(y(j)-y_vortex2,x(i)-x_vortex2);</div>
<div class="line">            psi(i,j) *= sqrt_density*exp(ci*phase);</div>
<div class="line"> </div>
<div class="line">            <span class="comment">// -x2,y2</span></div>
<div class="line">            phase=atan2(y(j)-y_vortex2,x(i)+x_vortex2);</div>
<div class="line">            psi(i,j) *= sqrt_density*exp(-ci*phase);</div>
<div class="line"> </div>
<div class="line">            <span class="comment">// x2,-y2</span></div>
<div class="line">            phase=atan2(y(j)+y_vortex2,x(i)-x_vortex2);</div>
<div class="line">            psi(i,j) *= sqrt_density*exp(-ci*phase);</div>
<div class="line"> </div>
<div class="line">            <span class="comment">// -x2,-y2</span></div>
<div class="line">            phase=atan2(y(j)+y_vortex2,x(i)+x_vortex2);</div>
<div class="line">            psi(i,j) *= sqrt_density*exp(ci*phase);</div>
<div class="line"> </div>
<div class="line">            <span class="comment">// Uncomment if you want to initialize a hard-wall box at the boundaries,</span></div>
<div class="line">            <span class="comment">// or to set the external potential that you want</span></div>
<div class="line"><span class="comment">//            if(i == 0 || j == 0 || i == nx-1 || j == ny-1 )</span></div>
<div class="line"><span class="comment">//                Vext(i,j) = 100;</span></div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> norm = 0.0;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; psi.size(); ++i) norm += std::norm(psi[i]);</div>
<div class="line">    norm *= dv;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; psi.size(); ++i) psi[i] *= std::sqrt(number_of_particles/norm);</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_dipoles2d.html">Dipoles2d</a> gp_solver(x,y,psi,Vext,scattering_length,dipolar_length,theta);</div>
<div class="line"> </div>
<div class="line">    std::fstream gradient_descent_output_stream;</div>
<div class="line">    gradient_descent_output_stream.open(<span class="stringliteral">&quot;gradient_descent_output.csv&quot;</span>,std::ios::out);</div>
<div class="line">    <span class="keywordtype">double</span> chemical_potential;</div>
<div class="line">    std::tie(psi,chemical_potential) = gp_solver.run_gradient_descent(number_of_gradient_descent_steps,</div>
<div class="line">                                                                      alpha,</div>
<div class="line">                                                                      beta,</div>
<div class="line">                                                                      std::cout,</div>
<div class="line">                                                                      write_output_every);</div>
<div class="line"> </div>
<div class="line">    gradient_descent_output_stream.close();</div>
<div class="line"> </div>
<div class="line">    gp_solver.reinit(Vext,psi);</div>
<div class="line">    gp_solver.run_operator_splitting(number_of_real_time_steps,time_step,std::cout,write_output_every);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line"> </div>
<div class="line">}</div>
<div class="ttc" id="aclass_ultra_cold_1_1_graphic_output_1_1_data_writer_html"><div class="ttname"><a href="class_ultra_cold_1_1_graphic_output_1_1_data_writer.html">UltraCold::GraphicOutput::DataWriter</a></div><div class="ttdoc">A class to output a data Vector in real space.</div><div class="ttdef"><b>Definition:</b> DataWriter.hpp:71</div></div>
<div class="ttc" id="aclass_ultra_cold_1_1_graphic_output_1_1_data_writer_html_a5379ac7b98c084855b372e863c095856"><div class="ttname"><a href="class_ultra_cold_1_1_graphic_output_1_1_data_writer.html#a5379ac7b98c084855b372e863c095856">UltraCold::GraphicOutput::DataWriter::set_output_name</a></div><div class="ttdeci">void set_output_name(const std::string &amp;output_file_name)</div><div class="ttdoc">Set the name for the output data file, input as an std::string.</div><div class="ttdef"><b>Definition:</b> DataWriter.cpp:31</div></div>
<div class="ttc" id="aclass_ultra_cold_1_1_graphic_output_1_1_data_writer_html_aec73552d1a4ccd5f3111c6268961279b"><div class="ttname"><a href="class_ultra_cold_1_1_graphic_output_1_1_data_writer.html#aec73552d1a4ccd5f3111c6268961279b">UltraCold::GraphicOutput::DataWriter::write_vtk</a></div><div class="ttdeci">void write_vtk(Vector&lt; double &gt; &amp;x_axis, Vector&lt; double &gt; &amp;y_axis, Vector&lt; double &gt; &amp;real_output_vector, const char *vector_name, const char *format)</div><div class="ttdoc">Write an output data file in .vtk format, for real 2D output.</div><div class="ttdef"><b>Definition:</b> DataWriter.cpp:805</div></div>
<div class="ttc" id="aclass_ultra_cold_1_1_tools_1_1_input_parser_html"><div class="ttname"><a href="class_ultra_cold_1_1_tools_1_1_input_parser.html">UltraCold::Tools::InputParser</a></div><div class="ttdoc">Class to read input parameters from files.</div><div class="ttdef"><b>Definition:</b> InputParser.hpp:93</div></div>
<div class="ttc" id="aclass_ultra_cold_1_1_vector_html"><div class="ttname"><a href="class_ultra_cold_1_1_vector.html">UltraCold::Vector&lt; double &gt;</a></div></div>
<div class="ttc" id="aclass_ultra_cold_1_1cuda_solvers_1_1_dipolar_g_p_solver_html"><div class="ttname"><a href="class_ultra_cold_1_1cuda_solvers_1_1_dipolar_g_p_solver.html">UltraCold::cudaSolvers::DipolarGPSolver</a></div><div class="ttdoc">GPU-accelerated solver for a dipolar Gross-Pitaevskii equation.</div><div class="ttdef"><b>Definition:</b> cudaDipolarGPSolver.cuh:43</div></div>
<div class="ttc" id="anamespace_ultra_cold_html"><div class="ttname"><a href="namespace_ultra_cold.html">UltraCold</a></div><div class="ttdoc">All the classes and functions necessary to work with UltraCold.</div><div class="ttdef"><b>Definition:</b> BogolyubovSolver.cpp:25</div></div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
