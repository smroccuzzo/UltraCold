<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>UltraCold: example-4</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/SVG"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">UltraCold
   </div>
   <div id="projectbrief">Collection of C++ libraries for the study of ultra-cold systems in the context of Gross-Pitaevskii theory</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('example-4.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">example-4 </div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#Title-4">Excitation spectrum of a trapped dipolar Bose-Einstein condensate across the superfluid-supersolid</a><ul><li class="level2"><a href="#Introduction-4">Introduction</a></li>
<li class="level2"><a href="#What-4">Program description</a></li>
<li class="level2"><a href="#Results-4">Results</a></li>
<li class="level2"><a href="#Possibilities-4">Possible extensions</a></li>
<li class="level2"><a href="#Uncommented-4">The plain program</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><dl class="section author"><dt>Author</dt><dd>Santo Maria Roccuzzo (<a href="#" onclick="location.href='mai'+'lto:'+'san'+'to'+'m.r'+'oc'+'cuz'+'zo'+'@gm'+'ai'+'l.c'+'om'; return false;">santo<span class="obfuscator">.nosp@m.</span>m.ro<span class="obfuscator">.nosp@m.</span>ccuzz<span class="obfuscator">.nosp@m.</span>o@gm<span class="obfuscator">.nosp@m.</span>ail.c<span class="obfuscator">.nosp@m.</span>om</a>)</dd></dl>
<h1><a class="anchor" id="Title-4"></a>
Excitation spectrum of a trapped dipolar Bose-Einstein condensate across the superfluid-supersolid</h1>
<p >phase transition.</p>
<h2><a class="anchor" id="Introduction-4"></a>
Introduction</h2>
<p >In this example, we are going to use UltraCold to study the elementary excitations of a three-dimensional, harmonically trapped <b>dipolar</b> Bose gas of \( ^{164}Dy \) atoms, using the solver class <code><a class="el" href="class_ultra_cold_1_1_bogolyubov_solvers_1_1_trapped_dipolar_bogolyubov_solver.html" title="Class to solve the Bogolyubov equations for a trapped dipolar Bose gas.">UltraCold::BogolyubovSolvers::TrappedDipolarBogolyubovSolver</a></code>, and across the superfluid-supersolid phase transition.</p>
<p >As explained in example-2, in order to calculate the spectrum of elementary excitations on top of a certain stationary solution of the GPe, it is necessary to search for solutions of the time-dependent GPe of the form</p>
<p class="formulaDsp">
\[
  \psi({\bf r},t) = e^{-i\frac{\mu}{\hbar}t}\left[ \psi_0({\bf r})
 + \sum_{n=0}^{\infty} \left( u_n({\bf r})e^{-i\omega_n t} + v^*_n({\bf r})e^{i\omega_n t} \right) \right]
\]
</p>
<p >and solve the eigenvalue problem that comes out by keeping only terms linear in the quasi-particle amplitudes \( u \) and \( v \). In the case of a <b>dipolar</b> Bose gas, taking also into account the effects of quantum fluctuations via the <a href="https://journals.aps.org/pra/abstract/10.1103/PhysRevA.86.063609">Lee-Huang-Yang </a> (LHY) correction, this amounts to solving the following eigenvalue problem</p>
<p class="formulaDsp">
\[

 \begin{bmatrix}
     u \\
     v
 \end{bmatrix}
     =
 \begin{bmatrix}
     \hat{H}-\mu+\hat{X} &amp; \hat{X}^\dagger \\
     -\hat{X} &amp; -(\hat{H}-\mu+\hat{X}^\dagger)
 \end{bmatrix}
 \begin{bmatrix}
     u \\
     v
 \end{bmatrix}

\]
</p>
<p >with</p>
<p class="formulaDsp">
\[
 \begin{align}
  \mathcal{H}({\bf r})=-&amp;\frac{\hbar^2}{2m}\nabla^2+V_{\rm ext}({\bf r})+g|\Psi({\bf r},t)|^2+\gamma
  (\varepsilon_{dd})|\Psi({\bf r},t)|^3\nonumber\\
  +&amp; \int d{\bf r&#39;}V_{dd}({\bf r}-{\bf r&#39;})|\Psi({\bf r&#39;},t)|^2\,,
 \end{align}
\]
</p>
<p> and</p>
<p class="formulaDsp">
\[

\hat{X}f({\bf r}) = \psi_0({\bf r})\int d{\bf r}&#39; V_{dd}({\bf r}-{\bf r}&#39;)f({\bf r}&#39;)\psi_0^*({\bf r}&#39;) +
\frac{3}{2}\gamma(\varepsilon_{dd})|\psi_0({\bf r})|^3f({\bf r})

\]
</p>
<p >and finally</p>
<p class="formulaDsp">
\[
 \gamma(\varepsilon_{dd})=\frac{16}{3\sqrt{\pi}} ga^{\frac{3}{2}}\,\mbox{Re}\bigg[\!\int_0^{\pi}
 \!\!\!\!d\theta\sin\theta [1+\varepsilon_{dd}(3\cos^2\theta-1)]^{\frac{5}{2}}\bigg]\,.
\]
</p>
<p >with \( g=4\pi\hbar^2a/m \) the coupling constant fixed by the \( s \)-wave scattering length \( a
\), \( V_{dd}({\bf r}_{i}-{\bf r}_{j})=\frac{\mu_0\mu^2}{4\pi}\frac{1-3\cos^2\theta}{|{\bf r}_{i}-{\bf
r}_{j}|^3} \) the dipole-dipole potential, being \( \mu_0 \) the magnetic permeability in vacuum, \(
\mu \) the magnetic dipole moment and \( \theta \) the angle between the vector distance between dipoles and the polarization direction, which we choose as the \( x \)-axis, and \( \varepsilon_{dd}=\mu_0\mu^2/(3g)=a_{dd}/a \) the ratio between the strength of the dipolar and the contact interaction, eventually written in terms of the dipolar length \( a_{dd} \) and the scattering length \( a \).</p>
<p >In the case in which the condensate wave function is real (e.g., in absence of vortices, solitons...) the problem can be recast in a more convenient form. In fact, taking the sum and the difference between the two equations, one easily finds</p>
<p class="formulaDsp">
\[
  \begin{align}
      &amp; (\hat{H}-\mu)(\hat{H}-\mu+2\hat{X}) (u+v) = (\hbar\omega)^2 (u+v) \nonumber \\
      &amp; (\hat{H}-\mu+2\hat{X})(\hat{H}-\mu) (u-v) = (\hbar\omega)^2 (u-v) \nonumber \\
  \end{align}
 \]
</p>
<p >Now, both equations allow to find the (square) of the energy of the Bogolyubov modes, but solving a system of half the dimensionality of the original problem. This typically allows a great saving of computational time. The eigenvectors of the two problems correspond to \((u+v)\) and \((u-v)\) respectively, so that if one is interested in finding the Bogolyubov quasi-particle amplitudes \( u \) and \( v \), one also needs to solve the second problem, and then set \( u = 0.5 \left( (u+v) + (u-v) \right)\) and \( v = 0.5 \left( (u+v) - (u-v) \right)\)</p>
<p >This class solves the eigenvalue problem using the matrix-free routines provided as part of the package <a href="https://github.com/opencollab/arpack-ng">arpack-ng </a>, which is distributed as a bundled package with <a class="el" href="namespace_ultra_cold.html" title="All the classes and functions necessary to work with UltraCold.">UltraCold</a>.</p>
<h2><a class="anchor" id="What-4"></a>
Program description</h2>
<p >As always, we first create an input file containing our mesh and physical parameters, as well as other parameters determining the run-time behavior of the system. Such input file will be called <code>example-4.prm</code> and contain the following text</p>
<pre class="fragment"># Mesh parameters

xmax = 20.0 # Size of the mesh along the x-axis, in micrometers. The mesh will extend from -xmax to xmax
ymax = 10.0 # Size of the mesh along the y-axis, in micrometers. The mesh will extend from -ymax to ymax
zmax = 20.0 # Size of the mesh along the z-axis, in micrometers. The mesh will extend from -zmax to zmax

nx = 48  # Number of points along the x-axis
ny = 48  # Number of points along the y-axis
nz = 256 # Number of points along the z-axis

# Physical parameters

scattering length = 95.0
dipolar_length      = 132.0 # Dipolar length in units of the Bohr radius
number of particles = 40000  # Total number of atoms
atomic mass         = 164    # Atomic mass, in atomic mass units
omegax = 110 # Harmonic frequency along the x-axis, in units of (2pi)Hz
omegay = 90 # Harmonic frequency along the y-axis, in units of (2pi)Hz
omegaz = 30 # Harmonic frequency along the z-axis, in units of (2pi)Hz

# Run parameters for gradient descent

number of gradient descent steps = 200000 # maximum number of gradient descent steps
residual                         = 1.E-12 # Threshold on the norm of the residual
alpha                            = 1.E-3 # gradient descent step
beta                             = 0.9   # step for the heavy-ball acceleration method

# Run parameters for Bogolyubov equations

number of modes = 50
calculate eigenvectors = true
tolerance = 1.E-8
maximum number of arnoldi iterations = 10000</pre><p >We read the input file as usual using the class <code> Tools::InputParser </code>, set harmonic units, create a mesh and set the initial wave function and external potential for the calculation of the stationary state of the system, on top of which we are going to calculate the elementary excitations. Using the parameters above, such ground state is going to be a supersolid state.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;UltraCold.hpp&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;random&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespace_ultra_cold.html">UltraCold</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_ultra_cold_1_1_tools_1_1_input_parser.html">Tools::InputParser</a> ip(<span class="stringliteral">&quot;example-4.prm&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    ip.read_input_file();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> xmax = ip.retrieve_double(<span class="stringliteral">&quot;xmax&quot;</span>);</div>
<div class="line">    <span class="keywordtype">double</span> ymax = ip.retrieve_double(<span class="stringliteral">&quot;ymax&quot;</span>);</div>
<div class="line">    <span class="keywordtype">double</span> zmax = ip.retrieve_double(<span class="stringliteral">&quot;zmax&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> nx = ip.retrieve_int(<span class="stringliteral">&quot;nx&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> ny = ip.retrieve_int(<span class="stringliteral">&quot;ny&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> nz = ip.retrieve_int(<span class="stringliteral">&quot;nz&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> scattering_length         = ip.retrieve_double(<span class="stringliteral">&quot;scattering length&quot;</span>);</div>
<div class="line">    <span class="keywordtype">double</span> dipolar_length            = ip.retrieve_double(<span class="stringliteral">&quot;dipolar_length&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span>    number_of_particles = ip.retrieve_int(<span class="stringliteral">&quot;number of particles&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> atomic_mass         = ip.retrieve_double(<span class="stringliteral">&quot;atomic mass&quot;</span>);</div>
<div class="line">    <span class="keywordtype">double</span> omegax                    = ip.retrieve_double(<span class="stringliteral">&quot;omegax&quot;</span>);</div>
<div class="line">    <span class="keywordtype">double</span> omegay                    = ip.retrieve_double(<span class="stringliteral">&quot;omegay&quot;</span>);</div>
<div class="line">    <span class="keywordtype">double</span> omegaz                    = ip.retrieve_double(<span class="stringliteral">&quot;omegaz&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span>    number_of_gradient_descent_steps = ip.retrieve_int(<span class="stringliteral">&quot;number of gradient descent steps&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> residual                         = ip.retrieve_double(<span class="stringliteral">&quot;residual&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> alpha                            = ip.retrieve_double(<span class="stringliteral">&quot;alpha&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> beta                             = ip.retrieve_double(<span class="stringliteral">&quot;beta&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> number_of_modes = ip.retrieve_int(<span class="stringliteral">&quot;number of modes&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> maximum_number_arnoldi_iterations = ip.retrieve_int(<span class="stringliteral">&quot;maximum number of arnoldi iterations&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> tolerance = ip.retrieve_double(<span class="stringliteral">&quot;tolerance&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span> calculate_eigenvectors = ip.retrieve_bool(<span class="stringliteral">&quot;calculate eigenvectors&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> hbar        = 0.6347*1.E5;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> bohr_radius = 5.292E-5;</div>
<div class="line"> </div>
<div class="line">    omegax *= TWOPI;</div>
<div class="line">    omegay *= TWOPI;</div>
<div class="line">    omegaz *= TWOPI;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> omega_ho = std::cbrt(omegax*omegay*omegaz);</div>
<div class="line"> </div>
<div class="line">    omegax = omegax/omega_ho;</div>
<div class="line">    omegay = omegay/omega_ho;</div>
<div class="line">    omegaz = omegaz/omega_ho;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> a_ho = std::sqrt(hbar/(atomic_mass*omega_ho));</div>
<div class="line"> </div>
<div class="line">    scattering_length *= bohr_radius/a_ho;</div>
<div class="line">    dipolar_length *= bohr_radius/a_ho;</div>
<div class="line"> </div>
<div class="line">    xmax = xmax/a_ho;</div>
<div class="line">    ymax = ymax/a_ho;</div>
<div class="line">    zmax = zmax/a_ho;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> dx = 2 * xmax / nx;</div>
<div class="line">    <span class="keywordtype">double</span> dy = 2 * ymax / ny;</div>
<div class="line">    <span class="keywordtype">double</span> dz = 2 * zmax / nz;</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_ultra_cold_1_1_vector.html">Vector&lt;double&gt;</a> x(nx), y(ny), z(nz), kx(nx), ky(ny), kz(nz);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nx; ++i) x[i] = -xmax + i * dx;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ny; ++i) y[i] = -ymax + i * dy;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nz; ++i) z[i] = -zmax + i * dz;</div>
<div class="line">    create_mesh_in_Fourier_space(x, y, z, kx, ky, kz);</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_ultra_cold_1_1_vector.html">Vector&lt;std::complex&lt;double&gt;</a>&gt; psi(nx, ny, nz);</div>
<div class="line">    <a class="code hl_class" href="class_ultra_cold_1_1_vector.html">Vector&lt;double&gt;</a> Vext(nx, ny, nz);</div>
<div class="line"> </div>
<div class="line">    std::default_random_engine generator;</div>
<div class="line">    std::uniform_real_distribution&lt;double&gt; distribution(0,1);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nx; ++i)</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; ny; ++j)</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; nz; ++k)</div>
<div class="line">            {</div>
<div class="line">                <span class="keywordtype">double</span> random_number = distribution(generator);</div>
<div class="line">                psi(i,j,k)  = (1.0+0.1*random_number)*</div>
<div class="line">                              std::exp(-0.1*(pow(x(i),2) +</div>
<div class="line">                                             pow(y(j),2) +</div>
<div class="line">                                             pow(z(k),2)) );</div>
<div class="line"> </div>
<div class="line">                Vext(i,j,k) = 0.5*( std::pow(omegax,2)*pow(x(i),2) +</div>
<div class="line">                                    std::pow(omegay,2)*pow(y(j),2) +</div>
<div class="line">                                    std::pow(omegaz,2)*pow(z(k),2) );</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> norm = 0.0;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; psi.size(); ++i) norm += std::norm(psi[i]);</div>
<div class="line">    norm *= (dx * dy * dz);</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; psi.size(); ++i) psi[i] *= std::sqrt(number_of_particles / norm);</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_ultra_cold_1_1_graphic_output_1_1_data_writer.html">UltraCold::GraphicOutput::DataWriter</a> psi_out;</div>
<div class="line">    psi_out.<a class="code hl_function" href="class_ultra_cold_1_1_graphic_output_1_1_data_writer.html#a5379ac7b98c084855b372e863c095856">set_output_name</a>(<span class="stringliteral">&quot;initial_wave_function&quot;</span>);</div>
<div class="line">    psi_out.<a class="code hl_function" href="class_ultra_cold_1_1_graphic_output_1_1_data_writer.html#a5b26fc2251c281fd95ff72c662e49640">write_slice2d_vtk</a>(x,y,psi,<span class="stringliteral">&quot;xy&quot;</span>,<span class="stringliteral">&quot;initial_wave_function&quot;</span>);</div>
<div class="ttc" id="aclass_ultra_cold_1_1_graphic_output_1_1_data_writer_html"><div class="ttname"><a href="class_ultra_cold_1_1_graphic_output_1_1_data_writer.html">UltraCold::GraphicOutput::DataWriter</a></div><div class="ttdoc">A class to output a data Vector in real space.</div><div class="ttdef"><b>Definition:</b> DataWriter.hpp:71</div></div>
<div class="ttc" id="aclass_ultra_cold_1_1_graphic_output_1_1_data_writer_html_a5379ac7b98c084855b372e863c095856"><div class="ttname"><a href="class_ultra_cold_1_1_graphic_output_1_1_data_writer.html#a5379ac7b98c084855b372e863c095856">UltraCold::GraphicOutput::DataWriter::set_output_name</a></div><div class="ttdeci">void set_output_name(const std::string &amp;output_file_name)</div><div class="ttdoc">Set the name for the output data file, input as an std::string.</div><div class="ttdef"><b>Definition:</b> DataWriter.cpp:31</div></div>
<div class="ttc" id="aclass_ultra_cold_1_1_graphic_output_1_1_data_writer_html_a5b26fc2251c281fd95ff72c662e49640"><div class="ttname"><a href="class_ultra_cold_1_1_graphic_output_1_1_data_writer.html#a5b26fc2251c281fd95ff72c662e49640">UltraCold::GraphicOutput::DataWriter::write_slice2d_vtk</a></div><div class="ttdeci">void write_slice2d_vtk(Vector&lt; double &gt; &amp;ax1, Vector&lt; double &gt; &amp;ax2, Vector&lt; double &gt; &amp;real_output_vector, const char *vector_name, const char *plane, const char *format)</div><div class="ttdoc">Write an output data file in .vtk format, for 2D slice of real 3D Vector.</div><div class="ttdef"><b>Definition:</b> DataWriter.cpp:1236</div></div>
<div class="ttc" id="aclass_ultra_cold_1_1_tools_1_1_input_parser_html"><div class="ttname"><a href="class_ultra_cold_1_1_tools_1_1_input_parser.html">UltraCold::Tools::InputParser</a></div><div class="ttdoc">Class to read input parameters from files.</div><div class="ttdef"><b>Definition:</b> InputParser.hpp:93</div></div>
<div class="ttc" id="aclass_ultra_cold_1_1_vector_html"><div class="ttname"><a href="class_ultra_cold_1_1_vector.html">UltraCold::Vector&lt; double &gt;</a></div></div>
<div class="ttc" id="anamespace_ultra_cold_html"><div class="ttname"><a href="namespace_ultra_cold.html">UltraCold</a></div><div class="ttdoc">All the classes and functions necessary to work with UltraCold.</div><div class="ttdef"><b>Definition:</b> BogolyubovSolver.cpp:25</div></div>
</div><!-- fragment --><p >So, we calculate the ground state of the system using the class <code> GPSolvers::DipolarGPSolver </code> </p><div class="fragment"><div class="line"><a class="code hl_class" href="class_ultra_cold_1_1_g_p_solvers_1_1_dipolar_g_p_solver.html">GPSolvers::DipolarGPSolver</a> dipolar_gp_solver(x,</div>
<div class="line">                                             y,</div>
<div class="line">                                             z,</div>
<div class="line">                                             psi,</div>
<div class="line">                                             Vext,</div>
<div class="line">                                             scattering_length,</div>
<div class="line">                                             dipolar_length);</div>
<div class="line"><span class="keywordtype">double</span> chemical_potential;</div>
<div class="line">std::tie(psi, chemical_potential) = dipolar_gp_solver.run_gradient_descent(number_of_gradient_descent_steps,</div>
<div class="line">                                                                           residual,</div>
<div class="line">                                                                           alpha,</div>
<div class="line">                                                                           beta,</div>
<div class="line">                                                                           std::cout);</div>
<div class="line"> </div>
<div class="line">psi_out.<a class="code hl_function" href="class_ultra_cold_1_1_graphic_output_1_1_data_writer.html#a5379ac7b98c084855b372e863c095856">set_output_name</a>(<span class="stringliteral">&quot;ground_state_wave_function&quot;</span>);</div>
<div class="line">psi_out.<a class="code hl_function" href="class_ultra_cold_1_1_graphic_output_1_1_data_writer.html#aec73552d1a4ccd5f3111c6268961279b">write_vtk</a>(x,y,z,psi,<span class="stringliteral">&quot;ground_state_wave_function&quot;</span>,<span class="stringliteral">&quot;BINARY&quot;</span>);</div>
<div class="ttc" id="aclass_ultra_cold_1_1_g_p_solvers_1_1_dipolar_g_p_solver_html"><div class="ttname"><a href="class_ultra_cold_1_1_g_p_solvers_1_1_dipolar_g_p_solver.html">UltraCold::GPSolvers::DipolarGPSolver</a></div><div class="ttdoc">Class to solve the Gross-Pitaevskii equation for a dipolar Bose gas in two or three space dimensions.</div><div class="ttdef"><b>Definition:</b> GPSolvers.hpp:467</div></div>
<div class="ttc" id="aclass_ultra_cold_1_1_graphic_output_1_1_data_writer_html_aec73552d1a4ccd5f3111c6268961279b"><div class="ttname"><a href="class_ultra_cold_1_1_graphic_output_1_1_data_writer.html#aec73552d1a4ccd5f3111c6268961279b">UltraCold::GraphicOutput::DataWriter::write_vtk</a></div><div class="ttdeci">void write_vtk(Vector&lt; double &gt; &amp;x_axis, Vector&lt; double &gt; &amp;y_axis, Vector&lt; double &gt; &amp;real_output_vector, const char *vector_name, const char *format)</div><div class="ttdoc">Write an output data file in .vtk format, for real 2D output.</div><div class="ttdef"><b>Definition:</b> DataWriter.cpp:805</div></div>
</div><!-- fragment --><p >We can now plug the calculated ground-state solution \( \psi_0 \) to the class <a class="el" href="class_ultra_cold_1_1_bogolyubov_solvers_1_1_trapped_dipolar_bogolyubov_solver.html" title="Class to solve the Bogolyubov equations for a trapped dipolar Bose gas.">UltraCold::BogolyubovSolvers::TrappedDipolarBogolyubovSolver</a>, which will calculate for us the energies of the elementary excitations of the system as well as the Bogolyubov amplitudes \( u \) and \( v \). Since we are considering a simple solution of the GPe, without any topological defect like solitons or vortices, the ground-state wave function, despite being defined as a complex Vector, will have only a non-zero real part. We can thus simplify the Bogolyubov equations solving only eigen-problems of halved dimensionality. The class <code><a class="el" href="class_ultra_cold_1_1_bogolyubov_solvers_1_1_trapped_dipolar_bogolyubov_solver.html" title="Class to solve the Bogolyubov equations for a trapped dipolar Bose gas.">UltraCold::BogolyubovSolvers::TrappedDipolarBogolyubovSolver</a></code> will do this automatically for us, provided that we feed a real Vector, representing the ground-state wave function, to its constructor. We thus first copy the calculated ground-state wave-function into a real-valued Vector</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="class_ultra_cold_1_1_vector.html">Vector&lt;double&gt;</a> psi_real(nx,ny,nz);</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nx * ny * nz; ++i)</div>
<div class="line">    psi_real[i] = psi[i].real();</div>
</div><!-- fragment --><p >then initialize the data structures that will contain the solutions of the Bogolyubov equations</p>
<div class="fragment"><div class="line">std::vector&lt;std::complex&lt;double&gt;&gt; eigenvalues(number_of_modes);</div>
<div class="line">std::vector&lt;Vector&lt;std::complex&lt;double&gt;&gt;&gt; u(number_of_modes),v(number_of_modes);</div>
</div><!-- fragment --><p >and, finally, create our solver class and run the solver</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="class_ultra_cold_1_1_bogolyubov_solvers_1_1_trapped_dipolar_bogolyubov_solver.html">BogolyubovSolvers::TrappedDipolarBogolyubovSolver</a> dipolar_bogolyubov_solver(x,</div>
<div class="line">                                                                            y,</div>
<div class="line">                                                                            z,</div>
<div class="line">                                                                            psi_real,</div>
<div class="line">                                                                            Vext,</div>
<div class="line">                                                                            scattering_length,</div>
<div class="line">                                                                            dipolar_length,</div>
<div class="line">                                                                            chemical_potential,</div>
<div class="line">                                                                            number_of_modes,</div>
<div class="line">                                                                            tolerance,</div>
<div class="line">                                                                            maximum_number_arnoldi_iterations,</div>
<div class="line">                                                                            calculate_eigenvectors);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">std::tie(eigenvalues,u,v) = dipolar_bogolyubov_solver.run();</div>
<div class="ttc" id="aclass_ultra_cold_1_1_bogolyubov_solvers_1_1_trapped_dipolar_bogolyubov_solver_html"><div class="ttname"><a href="class_ultra_cold_1_1_bogolyubov_solvers_1_1_trapped_dipolar_bogolyubov_solver.html">UltraCold::BogolyubovSolvers::TrappedDipolarBogolyubovSolver</a></div><div class="ttdoc">Class to solve the Bogolyubov equations for a trapped dipolar Bose gas.</div><div class="ttdef"><b>Definition:</b> BogolyubovSolvers.hpp:359</div></div>
</div><!-- fragment --><p >In the context of Bogolyubov theory, several interesting properties can be extracted from the knowledge of \( u \) and \( v \). For example, one can see the density and phase fluctuations associated with each eigen-mode, by looking, respectively, at the quantities</p>
<p class="formulaDsp">
\[

\begin{align}

    &amp; \delta n({\bf r}) = (u({\bf r}) + v({\bf r}))\psi_0({\bf r}) \nonumber \\
    &amp; \delta \phi({\bf r}) = (u({\bf r}) - v({\bf r}))/\psi_0({\bf r}) \nonumber \\

\end{align}

\]
</p>
<p >This is exactly what we calculate and output into some .vtk files with the last lines of the example. Notice that we also print to the screen the expected frequencies of the center-of-mass oscillations of the system, which in the case of harmonic trapping coincide with the harmonic frequencies of the trap (they will, of course, be printed in units of their geometric average). This is a useful test of the accuracy of the calculation. If the calculations were accurate, one must find such three frequencies in the calculated energy spectrum.</p>
<div class="fragment"><div class="line">    <a class="code hl_class" href="class_ultra_cold_1_1_graphic_output_1_1_data_writer.html">GraphicOutput::DataWriter</a>                    output_fluctuations;</div>
<div class="line">    std::vector&lt;Vector&lt; std::complex&lt;double&gt; &gt;&gt; density_fluctuations(number_of_modes);</div>
<div class="line">    std::vector&lt;Vector&lt; std::complex&lt;double&gt; &gt;&gt; phase_fluctuations(number_of_modes);</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------&quot;</span>     &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Expected dipole mode frequencies: &quot;</span>     &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; omegax &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; omegay &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; omegaz &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------&quot;</span>     &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; number_of_modes; ++i)</div>
<div class="line">    {</div>
<div class="line"> </div>
<div class="line">        std::cout &lt;&lt; eigenvalues[i].real() &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; eigenvalues[i].imag() &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span>(calculate_eigenvectors)</div>
<div class="line">        {</div>
<div class="line"> </div>
<div class="line">                density_fluctuations[i].reinit(nx,ny,nz);</div>
<div class="line">                phase_fluctuations[i].reinit(nx,ny,nz);</div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; nx*ny*nz; ++j)</div>
<div class="line">                {</div>
<div class="line">                        density_fluctuations[i](j) = (u[i](j) + v[i](j)) * psi_real(j);</div>
<div class="line">                        phase_fluctuations[i](j)   = (u[i](j) - v[i](j)) / psi_real(j);</div>
<div class="line">                }</div>
<div class="line"> </div>
<div class="line">                output_fluctuations.<a class="code hl_function" href="class_ultra_cold_1_1_graphic_output_1_1_data_writer.html#a5379ac7b98c084855b372e863c095856">set_output_name</a>(<span class="stringliteral">&quot;density_fluctuations_mode_&quot;</span> + std::to_string(i));</div>
<div class="line">                output_fluctuations.<a class="code hl_function" href="class_ultra_cold_1_1_graphic_output_1_1_data_writer.html#aec73552d1a4ccd5f3111c6268961279b">write_vtk</a>(x,y,z,density_fluctuations[i], <span class="stringliteral">&quot;density_fluctuations&quot;</span>,<span class="stringliteral">&quot;BINARY&quot;</span>);</div>
<div class="line"> </div>
<div class="line">                output_fluctuations.<a class="code hl_function" href="class_ultra_cold_1_1_graphic_output_1_1_data_writer.html#a5379ac7b98c084855b372e863c095856">set_output_name</a>(<span class="stringliteral">&quot;phase_fluctuations_mode_&quot;</span> + std::to_string(i));</div>
<div class="line">                output_fluctuations.<a class="code hl_function" href="class_ultra_cold_1_1_graphic_output_1_1_data_writer.html#aec73552d1a4ccd5f3111c6268961279b">write_vtk</a>(x,y,z,phase_fluctuations[i], <span class="stringliteral">&quot;phase_fluctuations&quot;</span>,<span class="stringliteral">&quot;BINARY&quot;</span>);</div>
<div class="line"> </div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line"> </div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="Results-4"></a>
Results</h2>
<p >It is first interesting to get a look at the calculated ground-state wave function. As said, with the parameters used here, it corresponds to a supersolid state, as we can see from the three-dimensional density contours</p>
<div class="image">
<img src="example-4-density-contours.png" alt=""/>
</div>
<p >The output of the program related to the (first) calculated eigenvalues, corresponding to the energies of the Bogolyubov modes in units of \( \hbar \omega_{ho} \), is the following:</p>
<pre class="fragment">--------------------------------------
Expected dipole-mode frequencies:
1.6487 1.34893 0.449644
--------------------------------------
7.35959e-06 0
0.0990846 0
0.290267 0
0.388278 0
0.449645 0
0.564145 0
0.569203 0
0.772583 0
0.993786 0
1.01476 0
1.01743 0
1.08948 0
1.09409 0
1.18436 0
1.2107 0
1.30721 0
1.31027 0
1.34772 0
1.5384 0
1.54054 0
1.58407 0
1.60403 0
1.61188 0
1.62087 0
1.66431 0
1.66592 0
1.67126 0
1.6948 0</pre><p >Notice that we catch well the two lowest dipole frequencies, and a little less well the higher energy one. This is not too much surprising, however, since at high energies even the dipole mode can be slightly affected by the other modes of comparable energy. It is also interesting to have a look at how the excitation spectrum changes when we tune the dipolar parameter \( \varepsilon_{dd}=\mu_0\mu^2/(3g)=a_{dd}/a \). The results look like the following</p>
<div class="image">
<img src="example-4-spectrum.png" alt=""/>
</div>
<dl class="section note"><dt>Note</dt><dd>Since Bogolyubov calculations in three space dimensions are numerically very demanding, most of the calculations required to obtain the results presented in this example have been done on the High Performance Computing cluster Galileo100 of the Italian supercomputing consortium <a href="https://www.cineca.it/en">CINECA </a>.</dd></dl>
<h2><a class="anchor" id="Possibilities-4"></a>
Possible extensions</h2>
<p >One can use the calculated Bogolyubov amplitudes \(u\) and \(v\), as well as the calculated density and phase fluctuations, to study for example the dynamic structure factor of the system, which describes the response of the system to small density probes, or the "character" of the modes, i.e. if a certain mode has mainly a density or a phase character. These kind of studies have led, in recent years, to several interesting publications, see for example <a href="https://www.nature.com/articles/s41586-019-1568-6">Nature volume 574, pages 382–385 (2019) </a>, <a href="https://www.nature.com/articles/s41586-019-1569-5">Nature volume 574, pages 386–389 (2019) </a>, and <a href="https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.123.050402">Phys. Rev. Lett. 123, 050402 (2019) </a></p>
<h2><a class="anchor" id="Uncommented-4"></a>
The plain program</h2>
<div class="fragment"><div class="line"><span class="comment">/*--------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> *    This file is part of the UltraCold project.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> *    UltraCold is free software: you can redistribute it and/or modify</span></div>
<div class="line"><span class="comment"> *    it under the terms of the GNU General Public License as published by</span></div>
<div class="line"><span class="comment"> *    the Free Software Foundation, either version 3 of the License, or</span></div>
<div class="line"><span class="comment"> *    any later version.</span></div>
<div class="line"><span class="comment"> *    UltraCold is distributed in the hope that it will be useful,</span></div>
<div class="line"><span class="comment"> *    but WITHOUT ANY WARRANTY; without even the implied warranty of</span></div>
<div class="line"><span class="comment"> *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span></div>
<div class="line"><span class="comment"> *    GNU General Public License for more details.</span></div>
<div class="line"><span class="comment"> *    You should have received a copy of the GNU General Public License</span></div>
<div class="line"><span class="comment"> *    along with UltraCold.  If not, see &lt;https://www.gnu.org/licenses/&gt;.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> *--------------------------------------------------------------------------------*/</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;UltraCold.hpp&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;random&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespace_ultra_cold.html">UltraCold</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_ultra_cold_1_1_tools_1_1_input_parser.html">Tools::InputParser</a> ip(<span class="stringliteral">&quot;example-4.prm&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    ip.read_input_file();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> xmax = ip.retrieve_double(<span class="stringliteral">&quot;xmax&quot;</span>);</div>
<div class="line">    <span class="keywordtype">double</span> ymax = ip.retrieve_double(<span class="stringliteral">&quot;ymax&quot;</span>);</div>
<div class="line">    <span class="keywordtype">double</span> zmax = ip.retrieve_double(<span class="stringliteral">&quot;zmax&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> nx = ip.retrieve_int(<span class="stringliteral">&quot;nx&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> ny = ip.retrieve_int(<span class="stringliteral">&quot;ny&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> nz = ip.retrieve_int(<span class="stringliteral">&quot;nz&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> scattering_length         = ip.retrieve_double(<span class="stringliteral">&quot;scattering length&quot;</span>);</div>
<div class="line">    <span class="keywordtype">double</span> dipolar_length            = ip.retrieve_double(<span class="stringliteral">&quot;dipolar_length&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span>    number_of_particles = ip.retrieve_int(<span class="stringliteral">&quot;number of particles&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> atomic_mass         = ip.retrieve_double(<span class="stringliteral">&quot;atomic mass&quot;</span>);</div>
<div class="line">    <span class="keywordtype">double</span> omegax                    = ip.retrieve_double(<span class="stringliteral">&quot;omegax&quot;</span>);</div>
<div class="line">    <span class="keywordtype">double</span> omegay                    = ip.retrieve_double(<span class="stringliteral">&quot;omegay&quot;</span>);</div>
<div class="line">    <span class="keywordtype">double</span> omegaz                    = ip.retrieve_double(<span class="stringliteral">&quot;omegaz&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span>    number_of_gradient_descent_steps = ip.retrieve_int(<span class="stringliteral">&quot;number of gradient descent steps&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> residual                         = ip.retrieve_double(<span class="stringliteral">&quot;residual&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> alpha                            = ip.retrieve_double(<span class="stringliteral">&quot;alpha&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> beta                             = ip.retrieve_double(<span class="stringliteral">&quot;beta&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> number_of_modes = ip.retrieve_int(<span class="stringliteral">&quot;number of modes&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> maximum_number_arnoldi_iterations = ip.retrieve_int(<span class="stringliteral">&quot;maximum number of arnoldi iterations&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> tolerance = ip.retrieve_double(<span class="stringliteral">&quot;tolerance&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span> calculate_eigenvectors = ip.retrieve_bool(<span class="stringliteral">&quot;calculate eigenvectors&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> hbar        = 0.6347*1.E5;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> bohr_radius = 5.292E-5;</div>
<div class="line"> </div>
<div class="line">    omegax *= TWOPI;</div>
<div class="line">    omegay *= TWOPI;</div>
<div class="line">    omegaz *= TWOPI;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> omega_ho = std::cbrt(omegax*omegay*omegaz);</div>
<div class="line"> </div>
<div class="line">    omegax = omegax/omega_ho;</div>
<div class="line">    omegay = omegay/omega_ho;</div>
<div class="line">    omegaz = omegaz/omega_ho;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> a_ho = std::sqrt(hbar/(atomic_mass*omega_ho));</div>
<div class="line"> </div>
<div class="line">    scattering_length *= bohr_radius/a_ho;</div>
<div class="line">    dipolar_length *= bohr_radius/a_ho;</div>
<div class="line"> </div>
<div class="line">    xmax = xmax/a_ho;</div>
<div class="line">    ymax = ymax/a_ho;</div>
<div class="line">    zmax = zmax/a_ho;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> dx = 2 * xmax / nx;</div>
<div class="line">    <span class="keywordtype">double</span> dy = 2 * ymax / ny;</div>
<div class="line">    <span class="keywordtype">double</span> dz = 2 * zmax / nz;</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_ultra_cold_1_1_vector.html">Vector&lt;double&gt;</a> x(nx), y(ny), z(nz), kx(nx), ky(ny), kz(nz);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nx; ++i) x[i] = -xmax + i * dx;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ny; ++i) y[i] = -ymax + i * dy;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nz; ++i) z[i] = -zmax + i * dz;</div>
<div class="line">    create_mesh_in_Fourier_space(x, y, z, kx, ky, kz);</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_ultra_cold_1_1_vector.html">Vector&lt;std::complex&lt;double&gt;</a>&gt; psi(nx, ny, nz);</div>
<div class="line">    <a class="code hl_class" href="class_ultra_cold_1_1_vector.html">Vector&lt;double&gt;</a> Vext(nx, ny, nz);</div>
<div class="line"> </div>
<div class="line">    std::default_random_engine generator;</div>
<div class="line">    std::uniform_real_distribution&lt;double&gt; distribution(0,1);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nx; ++i)</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; ny; ++j)</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; nz; ++k)</div>
<div class="line">            {</div>
<div class="line">                <span class="keywordtype">double</span> random_number = distribution(generator);</div>
<div class="line">                psi(i,j,k)  = (1.0+0.1*random_number)*</div>
<div class="line">                              std::exp(-0.1*(pow(x(i),2) +</div>
<div class="line">                                             pow(y(j),2) +</div>
<div class="line">                                             pow(z(k),2)) );</div>
<div class="line"> </div>
<div class="line">                Vext(i,j,k) = 0.5*( std::pow(omegax,2)*pow(x(i),2) +</div>
<div class="line">                                    std::pow(omegay,2)*pow(y(j),2) +</div>
<div class="line">                                    std::pow(omegaz,2)*pow(z(k),2) );</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> norm = 0.0;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; psi.size(); ++i) norm += std::norm(psi[i]);</div>
<div class="line">    norm *= (dx * dy * dz);</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; psi.size(); ++i) psi[i] *= std::sqrt(number_of_particles / norm);</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_ultra_cold_1_1_graphic_output_1_1_data_writer.html">UltraCold::GraphicOutput::DataWriter</a> psi_out;</div>
<div class="line">    psi_out.<a class="code hl_function" href="class_ultra_cold_1_1_graphic_output_1_1_data_writer.html#a5379ac7b98c084855b372e863c095856">set_output_name</a>(<span class="stringliteral">&quot;initial_wave_function&quot;</span>);</div>
<div class="line">    psi_out.<a class="code hl_function" href="class_ultra_cold_1_1_graphic_output_1_1_data_writer.html#a5b26fc2251c281fd95ff72c662e49640">write_slice2d_vtk</a>(x,y,psi,<span class="stringliteral">&quot;xy&quot;</span>,<span class="stringliteral">&quot;initial_wave_function&quot;</span>,<span class="stringliteral">&quot;ASCII&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_ultra_cold_1_1_g_p_solvers_1_1_dipolar_g_p_solver.html">GPSolvers::DipolarGPSolver</a> dipolar_gp_solver(x,</div>
<div class="line">                                                 y,</div>
<div class="line">                                                 z,</div>
<div class="line">                                                 psi,</div>
<div class="line">                                                 Vext,</div>
<div class="line">                                                 scattering_length,</div>
<div class="line">                                                 dipolar_length);</div>
<div class="line">    <span class="keywordtype">double</span> chemical_potential;</div>
<div class="line">    std::tie(psi, chemical_potential) = dipolar_gp_solver.run_gradient_descent(number_of_gradient_descent_steps,</div>
<div class="line">                                                                               residual,</div>
<div class="line">                                                                               alpha,</div>
<div class="line">                                                                               beta,</div>
<div class="line">                                                                               std::cout);</div>
<div class="line"> </div>
<div class="line">    psi_out.<a class="code hl_function" href="class_ultra_cold_1_1_graphic_output_1_1_data_writer.html#a5379ac7b98c084855b372e863c095856">set_output_name</a>(<span class="stringliteral">&quot;ground_state_wave_function&quot;</span>);</div>
<div class="line">    psi_out.<a class="code hl_function" href="class_ultra_cold_1_1_graphic_output_1_1_data_writer.html#aec73552d1a4ccd5f3111c6268961279b">write_vtk</a>(x,y,z,psi,<span class="stringliteral">&quot;ground_state_wave_function&quot;</span>,<span class="stringliteral">&quot;BINARY&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_ultra_cold_1_1_vector.html">Vector&lt;double&gt;</a> psi_real(nx,ny,nz);</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nx * ny * nz; ++i)</div>
<div class="line">        psi_real[i] = psi[i].real();</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;std::complex&lt;double&gt;&gt; eigenvalues(number_of_modes);</div>
<div class="line">    std::vector&lt;Vector&lt;std::complex&lt;double&gt;&gt;&gt; u(number_of_modes),v(number_of_modes);</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_ultra_cold_1_1_bogolyubov_solvers_1_1_trapped_dipolar_bogolyubov_solver.html">BogolyubovSolvers::TrappedDipolarBogolyubovSolver</a> dipolar_bogolyubov_solver(x,</div>
<div class="line">                                                                                y,</div>
<div class="line">                                                                                z,</div>
<div class="line">                                                                                psi_real,</div>
<div class="line">                                                                                Vext,</div>
<div class="line">                                                                                scattering_length,</div>
<div class="line">                                                                                dipolar_length,</div>
<div class="line">                                                                                chemical_potential,</div>
<div class="line">                                                                                number_of_modes,</div>
<div class="line">                                                                                tolerance,</div>
<div class="line">                                                                                maximum_number_arnoldi_iterations,</div>
<div class="line">                                                                                calculate_eigenvectors);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    std::tie(eigenvalues,u,v) = dipolar_bogolyubov_solver.run();</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_ultra_cold_1_1_graphic_output_1_1_data_writer.html">GraphicOutput::DataWriter</a>                    output_fluctuations;</div>
<div class="line">    std::vector&lt;Vector&lt; std::complex&lt;double&gt; &gt;&gt; density_fluctuations(number_of_modes);</div>
<div class="line">    std::vector&lt;Vector&lt; std::complex&lt;double&gt; &gt;&gt; phase_fluctuations(number_of_modes);</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------&quot;</span>     &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Expected dipole mode frequencies: &quot;</span>     &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; omegax &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; omegay &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; omegaz &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------&quot;</span>     &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; number_of_modes; ++i)</div>
<div class="line">    {</div>
<div class="line"> </div>
<div class="line">        std::cout &lt;&lt; eigenvalues[i].real() &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; eigenvalues[i].imag() &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span>(calculate_eigenvectors)</div>
<div class="line">        {</div>
<div class="line"> </div>
<div class="line">                density_fluctuations[i].reinit(nx,ny,nz);</div>
<div class="line">                phase_fluctuations[i].reinit(nx,ny,nz);</div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; nx*ny*nz; ++j)</div>
<div class="line">                {</div>
<div class="line">                        density_fluctuations[i](j) = (u[i](j) + v[i](j)) * psi_real(j);</div>
<div class="line">                        phase_fluctuations[i](j)   = (u[i](j) - v[i](j)) / psi_real(j);</div>
<div class="line">                }</div>
<div class="line"> </div>
<div class="line">                output_fluctuations.<a class="code hl_function" href="class_ultra_cold_1_1_graphic_output_1_1_data_writer.html#a5379ac7b98c084855b372e863c095856">set_output_name</a>(<span class="stringliteral">&quot;density_fluctuations_mode_&quot;</span> + std::to_string(i));</div>
<div class="line">                output_fluctuations.<a class="code hl_function" href="class_ultra_cold_1_1_graphic_output_1_1_data_writer.html#aec73552d1a4ccd5f3111c6268961279b">write_vtk</a>(x,y,z,density_fluctuations[i], <span class="stringliteral">&quot;density_fluctuations&quot;</span>,<span class="stringliteral">&quot;BINARY&quot;</span>);</div>
<div class="line"> </div>
<div class="line">                output_fluctuations.<a class="code hl_function" href="class_ultra_cold_1_1_graphic_output_1_1_data_writer.html#a5379ac7b98c084855b372e863c095856">set_output_name</a>(<span class="stringliteral">&quot;phase_fluctuations_mode_&quot;</span> + std::to_string(i));</div>
<div class="line">                output_fluctuations.<a class="code hl_function" href="class_ultra_cold_1_1_graphic_output_1_1_data_writer.html#aec73552d1a4ccd5f3111c6268961279b">write_vtk</a>(x,y,z,phase_fluctuations[i], <span class="stringliteral">&quot;phase_fluctuations&quot;</span>,<span class="stringliteral">&quot;BINARY&quot;</span>);</div>
<div class="line"> </div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line"> </div>
<div class="line">}</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
