<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>UltraCold: example-2</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/SVG"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">UltraCold
   </div>
   <div id="projectbrief">Collection of C++ libraries for the study of ultra-cold systems in the context of Gross-Pitaevskii theory</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('example-2.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">example-2 </div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#Title-2">Bogolyubov equations for a two-dimensional Bose gas in a harmonic trap.</a><ul><li class="level2"><a href="#Introduction-2">Introduction</a></li>
<li class="level2"><a href="#What-2">Program description</a></li>
<li class="level2"><a href="#Results-2">Results</a></li>
<li class="level2"><a href="#Uncommented-2">The plain program</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><dl class="section author"><dt>Author</dt><dd>Santo Maria Roccuzzo (<a href="#" onclick="location.href='mai'+'lto:'+'san'+'to'+'m.r'+'oc'+'cuz'+'zo'+'@gm'+'ai'+'l.c'+'om'; return false;">santo<span class="obfuscator">.nosp@m.</span>m.ro<span class="obfuscator">.nosp@m.</span>ccuzz<span class="obfuscator">.nosp@m.</span>o@gm<span class="obfuscator">.nosp@m.</span>ail.c<span class="obfuscator">.nosp@m.</span>om</a>)</dd></dl>
<h1><a class="anchor" id="Title-2"></a>
Bogolyubov equations for a two-dimensional Bose gas in a harmonic trap.</h1>
<h2><a class="anchor" id="Introduction-2"></a>
Introduction</h2>
<p >In the second example, we are going to use UltraCold to study the elementary excitations on top of the ground state of a two-dimensional, harmonically trapped Bose gas, by solving the so-called <em>Bogolyubov equations</em>. We will use the solver class <code><a class="el" href="class_ultra_cold_1_1_bogolyubov_solvers_1_1_trapped_bogolyubov_solver.html" title="Class to solve the Bogolyubov equations for a trapped Bose gas.">UltraCold::BogolyubovSolvers::TrappedBogolyubovSolver</a></code>, which allows in fact to solve Bogolyubov equations for a simple Bose gas in the presence of an arbitrary external potential.</p>
<p >Starting from the a-dimensional Gross-Pitaevskii equation (GPe) in two space dimensions (assume we have already done some dimensional reduction integrating away the z-coordinate. This should lead to a renormalization of the scattering length, which we do not implement here because of laziness and because it does not affect, at least qualitatively, the physics) in the presence of an external harmonic potential</p>
<p class="formulaDsp">
\[
    i\frac{\partial \psi(x,y,t)}{\partial t} =
    \left[
        \frac{-\nabla^2}{2}+\frac{1}{2}(\omega_x^2 x^2+\omega^2_y y^2)
        + 4\pi a  |\psi(x,y,t)|^2
    \right]\psi(x,y,z,t)
\]
</p>
<p >one first searches for stationary solutions of the form</p>
<p class="formulaDsp">
\[
    \psi({\bf r},t) = \psi({\bf r})e^{-i\frac{\mu}{\hbar}t}
\]
</p>
<p >obtaining the time-independent eigenvalue problem</p>
<p class="formulaDsp">
\[
   \mu \psi({\bf r}) =
    \left[
        \frac{-\nabla^2}{2}+\frac{1}{2}(\omega_x^2 x^2+\omega^2_y y^2)
        + 4\pi a  |\psi({\bf r})|^2
    \right]\psi({\bf r})
\]
</p>
<p >The solution \( \psi_0 \) corresponding to the smallest eigenvalue \( \mu \) is interpreted as the ground-state of the system, and the corresponding eigenvalue \( \mu \) as the chemical potential. <br  />
 In order to study the elementary excitations of the system on top of a certain ground-state solution, it is common to search for solutions of the time-dependent GPe of the form</p>
<p class="formulaDsp">
\[
  \psi({\bf r},t) = e^{-i\frac{\mu}{\hbar}t}\left[ \psi_0({\bf r})
   + \sum_{n=0}^{\infty} \left( u_n({\bf r})e^{-i\omega_n t} + v^*_n({\bf r})e^{i\omega_n t} \right) \right]
\]
</p>
<p >Plugging this ansatz into the GPe and keeping only terms linear in the functions \( u \) and \( v \), one obtains the following eigenvalue problem</p>
<p class="formulaDsp">
\[

 \begin{bmatrix}
     u \\
     v
 \end{bmatrix}
     =
 \begin{bmatrix}
     -\frac{\nabla^2}{2} + V_{ext}({\bf r}) + 4\pi a |\psi_0|^2 - \mu &amp; 4\pi a \psi_0^2 \\
     - 4\pi a (\psi_0^*)^2 &amp;  -\left(-\frac{\nabla^2}{2} + V_{ext}({\bf r}) + 4 \pi a |\psi_0|^2-\mu\right)
 \end{bmatrix}
 \begin{bmatrix}
     u \\
     v
 \end{bmatrix}

\]
</p>
<p >which defines the so-called <em>Bogolyubov equations</em>. The solutions of these equations allows to study the energy of the elementary excitations of the system (<em>Bogolyubov modes</em>), as well as several interesting properties relative to the linear response of the system to external perturbations (see any book on Bose-Einstein condensation).</p>
<p >In the case in which the condensate ground-state wave function is real (e.g., in absence of vortices, solitons...) the problem can be recast in a more convenient form. In fact, taking the sum and the difference between the two equations, one easily finds</p>
<p class="formulaDsp">
\[
 \begin{align}
     &amp; \hat{H}\hat{X} (u+v) = (\hbar\omega)^2 (u+v) \nonumber \\
     &amp; \hat{X}\hat{H} (u-v) = (\hbar\omega)^2 (u-v) \nonumber \\
 \end{align}
\]
</p>
<p >with</p>
<p class="formulaDsp">
\[
 \begin{align}
     &amp; \hat{H} = -\frac{\nabla^2}{2} + V_{ext}({\bf r}) + 4  \pi a |\psi_0|^2 - \mu\nonumber \\
     &amp; \hat{X} = -\frac{\nabla^2}{2} + V_{ext}({\bf r}) + 12 \pi a |\psi_0|^2 - \mu \nonumber \\
 \end{align}
\]
</p>
<p >Now, both equations allow to find the (square) of the energy of the Bogolyubov modes, but solving a system of half the dimensionality of the original problem. This typically allows a great saving of computational time. The eigenvectors of the two problems correspond to \((u+v)\) and \((u-v)\) respectively, so that if one is interested in finding the Bogolyubov quasi-particle amplitudes \( u \) and \( v \), one also needs to solve the second problem, and then set \( u = 0.5 \left( (u+v) + (u-v) \right)\) and \( v = 0.5 \left( (u+v) - (u-v) \right)\)</p>
<h2><a class="anchor" id="What-2"></a>
Program description</h2>
<p >For this example, we first need to calculate a ground state solution of the GPe for a certain set of physical and mesh parameter. Differently from example-1, we do not need anything special from this calculation, so we don't need to derive any class for our <code><a class="el" href="class_ultra_cold_1_1_g_p_solvers_1_1_g_p_solver.html" title="Class to solve the Gross-Pitaevskii equation.">UltraCold::GPSolvers::GPSolver</a></code> base class. Nonetheless, the input parameters describing the physics and the mesh can be practically the same as in example-1, except that we remove any reference to the z-axis. Our input file, called <code>example-2.prm</code>, will thus contain the following text</p>
<pre class="fragment"># Mesh parameters

xmax = 15.0 # Size of the mesh along the x-axis, in micrometers. The mesh will extend from -xmax to xmax
ymax = 15.0 # Size of the mesh along the y-axis, in micrometers. The mesh will extend from -ymax to ymax

nx = 128 # Number of points along the x-axis
ny = 128 # Number of points along the y-axis

# Physical parameters

scattering length   = 100.9  # Initial scattering length in units of the Bohr radius
number of particles = 40000  # Total number of atoms
atomic mass         = 87     # Atomic mass, in atomic mass units
omegax              = 100 # Harmonic frequency along the x-axis, in units of (2pi)Hz
omegay              = 100 # Harmonic frequency along the y-axis, in units of (2pi)Hz

# Run parameters for gradient descent

number of gradient descent steps = 50000 # maximum number of gradient descent steps
residual                         = 1.E-8 # Threshold on the norm of the residual
alpha                            = 1.E-4 # gradient descent step
beta                             = 0.9   # step for the heavy-ball acceleration method

# Run parameters for Bogolyubov equations

number of modes = 50
calculate eigenvectors = true
tolerance = 1.E-12
maximum number of arnoldi iterations = 1000</pre><p >Let's now take a look at the source code contained in the file <code>/examples/example-2/example-2.cpp</code>.</p>
<p >The first lines again includes the header file <code>"UltraCold.hpp"</code> and import the namespace <a class="el" href="namespace_ultra_cold.html" title="All the classes and functions necessary to work with UltraCold.">UltraCold</a></p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;UltraCold.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespace_ultra_cold.html">UltraCold</a>;</div>
<div class="ttc" id="anamespace_ultra_cold_html"><div class="ttname"><a href="namespace_ultra_cold.html">UltraCold</a></div><div class="ttdoc">All the classes and functions necessary to work with UltraCold.</div><div class="ttdef"><b>Definition:</b> BogolyubovSolver.cpp:25</div></div>
</div><!-- fragment --><p >As in example-1, we first calculate a ground-state solution of the GPe using the function <code> run_gradient_descent(...)</code> from the class <a class="el" href="class_ultra_cold_1_1_g_p_solvers_1_1_g_p_solver.html" title="Class to solve the Gross-Pitaevskii equation.">UltraCold::GPSolvers::GPSolver</a>. We don't go into much details here, since it is practically the same as in example-1</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_ultra_cold_1_1_tools_1_1_input_parser.html">Tools::InputParser</a> ip(<span class="stringliteral">&quot;../example-2.prm&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    ip.read_input_file();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> xmax = ip.retrieve_double(<span class="stringliteral">&quot;xmax&quot;</span>);</div>
<div class="line">    <span class="keywordtype">double</span> ymax = ip.retrieve_double(<span class="stringliteral">&quot;ymax&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> nx = ip.retrieve_int(<span class="stringliteral">&quot;nx&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> ny = ip.retrieve_int(<span class="stringliteral">&quot;ny&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span>       scattering_length   = ip.retrieve_double(<span class="stringliteral">&quot;scattering length&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span>    number_of_particles = ip.retrieve_int(<span class="stringliteral">&quot;number of particles&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> atomic_mass         = ip.retrieve_double(<span class="stringliteral">&quot;atomic mass&quot;</span>);</div>
<div class="line">    <span class="keywordtype">double</span> omegax                    = ip.retrieve_double(<span class="stringliteral">&quot;omegax&quot;</span>);</div>
<div class="line">    <span class="keywordtype">double</span> omegay                    = ip.retrieve_double(<span class="stringliteral">&quot;omegay&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span>    number_of_gradient_descent_steps = ip.retrieve_int(<span class="stringliteral">&quot;number of gradient descent steps&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> residual                         = ip.retrieve_double(<span class="stringliteral">&quot;residual&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> alpha                            = ip.retrieve_double(<span class="stringliteral">&quot;alpha&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> beta                             = ip.retrieve_double(<span class="stringliteral">&quot;beta&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> number_of_modes = ip.retrieve_int(<span class="stringliteral">&quot;number of modes&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> maximum_number_arnoldi_iterations = ip.retrieve_int(<span class="stringliteral">&quot;maximum number of arnoldi iterations&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> tolerance = ip.retrieve_double(<span class="stringliteral">&quot;tolerance&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span> calculate_eigenvectors = ip.retrieve_bool(<span class="stringliteral">&quot;calculate eigenvectors&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> hbar        = 0.6347*1.E5;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> bohr_radius = 5.292E-5;</div>
<div class="line"> </div>
<div class="line">    omegax *= TWOPI;</div>
<div class="line">    omegay *= TWOPI;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> omega_ho = std::sqrt(omegax*omegay);</div>
<div class="line"> </div>
<div class="line">    omegax = omegax/omega_ho;</div>
<div class="line">    omegay = omegay/omega_ho;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> a_ho = std::sqrt(hbar/(atomic_mass*omega_ho));</div>
<div class="line"> </div>
<div class="line">    scattering_length   *= bohr_radius/a_ho;</div>
<div class="line"> </div>
<div class="line">    xmax = xmax/a_ho;</div>
<div class="line">    ymax = ymax/a_ho;</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_ultra_cold_1_1_vector.html">Vector&lt;double&gt;</a> x(nx);</div>
<div class="line">    <a class="code hl_class" href="class_ultra_cold_1_1_vector.html">Vector&lt;double&gt;</a> y(ny);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> dx = 2.*xmax/nx;</div>
<div class="line">    <span class="keywordtype">double</span> dy = 2.*ymax/ny;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; nx; ++i) x(i) = -xmax + i*dx;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; ny; ++i) y(i) = -ymax + i*dy;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> dv = dx*dy;</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_ultra_cold_1_1_vector.html">Vector&lt;std::complex&lt;double&gt;</a>&gt; psi(nx,ny);</div>
<div class="line">    <a class="code hl_class" href="class_ultra_cold_1_1_vector.html">Vector&lt;double&gt;</a> Vext(nx,ny);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; nx; ++i)</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; ny; ++j)</div>
<div class="line">            {</div>
<div class="line"> </div>
<div class="line">                psi(i,j)  = exp(- (pow(x(i),2) + pow(y(j),2)) );</div>
<div class="line"> </div>
<div class="line">                Vext(i,j) = 0.5*( std::pow(omegax,2)*pow(x(i),2) +</div>
<div class="line">                                  std::pow(omegay,2)*pow(y(j),2));</div>
<div class="line"> </div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> norm = 0.0;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; psi.size(); ++i) norm += std::norm(psi[i]);</div>
<div class="line">    norm *= dv;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; psi.size(); ++i) psi[i] *= std::sqrt(number_of_particles/norm);</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_ultra_cold_1_1_g_p_solvers_1_1_g_p_solver.html">GPSolvers::GPSolver</a> gp_solver(x,</div>
<div class="line">                                  y,</div>
<div class="line">                                  psi,</div>
<div class="line">                                  Vext,</div>
<div class="line">                                  scattering_length);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> chemical_potential;</div>
<div class="line">    std::tie(psi,chemical_potential) = gp_solver.run_gradient_descent(number_of_gradient_descent_steps,</div>
<div class="line">                                                                      residual,</div>
<div class="line">                                                                      alpha,</div>
<div class="line">                                                                      beta,</div>
<div class="line">                                                                      std::cout);</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_ultra_cold_1_1_graphic_output_1_1_data_writer.html">GraphicOutput::DataWriter</a> output_wave_function;</div>
<div class="line">    output_wave_function.<a class="code hl_function" href="class_ultra_cold_1_1_graphic_output_1_1_data_writer.html#a5379ac7b98c084855b372e863c095856">set_output_name</a>(<span class="stringliteral">&quot;ground_state_wave_function&quot;</span>);</div>
<div class="line">    output_wave_function.<a class="code hl_function" href="class_ultra_cold_1_1_graphic_output_1_1_data_writer.html#aec73552d1a4ccd5f3111c6268961279b">write_vtk</a>(x,y,psi,<span class="stringliteral">&quot;ground_state_wave_function&quot;</span>,<span class="stringliteral">&quot;ASCII&quot;</span>);</div>
<div class="ttc" id="aclass_ultra_cold_1_1_g_p_solvers_1_1_g_p_solver_html"><div class="ttname"><a href="class_ultra_cold_1_1_g_p_solvers_1_1_g_p_solver.html">UltraCold::GPSolvers::GPSolver</a></div><div class="ttdoc">Class to solve the Gross-Pitaevskii equation.</div><div class="ttdef"><b>Definition:</b> GPSolvers.hpp:161</div></div>
<div class="ttc" id="aclass_ultra_cold_1_1_graphic_output_1_1_data_writer_html"><div class="ttname"><a href="class_ultra_cold_1_1_graphic_output_1_1_data_writer.html">UltraCold::GraphicOutput::DataWriter</a></div><div class="ttdoc">A class to output a data Vector in real space.</div><div class="ttdef"><b>Definition:</b> DataWriter.hpp:71</div></div>
<div class="ttc" id="aclass_ultra_cold_1_1_graphic_output_1_1_data_writer_html_a5379ac7b98c084855b372e863c095856"><div class="ttname"><a href="class_ultra_cold_1_1_graphic_output_1_1_data_writer.html#a5379ac7b98c084855b372e863c095856">UltraCold::GraphicOutput::DataWriter::set_output_name</a></div><div class="ttdeci">void set_output_name(const std::string &amp;output_file_name)</div><div class="ttdoc">Set the name for the output data file, input as an std::string.</div><div class="ttdef"><b>Definition:</b> DataWriter.cpp:31</div></div>
<div class="ttc" id="aclass_ultra_cold_1_1_graphic_output_1_1_data_writer_html_aec73552d1a4ccd5f3111c6268961279b"><div class="ttname"><a href="class_ultra_cold_1_1_graphic_output_1_1_data_writer.html#aec73552d1a4ccd5f3111c6268961279b">UltraCold::GraphicOutput::DataWriter::write_vtk</a></div><div class="ttdeci">void write_vtk(Vector&lt; double &gt; &amp;x_axis, Vector&lt; double &gt; &amp;y_axis, Vector&lt; double &gt; &amp;real_output_vector, const char *vector_name, const char *format)</div><div class="ttdoc">Write an output data file in .vtk format, for real 2D output.</div><div class="ttdef"><b>Definition:</b> DataWriter.cpp:805</div></div>
<div class="ttc" id="aclass_ultra_cold_1_1_tools_1_1_input_parser_html"><div class="ttname"><a href="class_ultra_cold_1_1_tools_1_1_input_parser.html">UltraCold::Tools::InputParser</a></div><div class="ttdoc">Class to read input parameters from files.</div><div class="ttdef"><b>Definition:</b> InputParser.hpp:93</div></div>
<div class="ttc" id="aclass_ultra_cold_1_1_vector_html"><div class="ttname"><a href="class_ultra_cold_1_1_vector.html">UltraCold::Vector&lt; double &gt;</a></div></div>
</div><!-- fragment --><p >We can now plug the calculated ground-state solution \( \psi_0 \) to the class <a class="el" href="class_ultra_cold_1_1_bogolyubov_solvers_1_1_trapped_bogolyubov_solver.html" title="Class to solve the Bogolyubov equations for a trapped Bose gas.">UltraCold::BogolyubovSolvers::TrappedBogolyubovSolver</a>, which will calculate for us the energies of the eigen-modes of the system as well as the Bogolyubov amplitudes \( u \) and \( v \). Since we are considering a simple solution of the GPe, without any topological defect like solitons or vortices, the ground-state wave function, despite being defined as a complex Vector, will have only a non-zero real part. We can thus simplify the Bogolyubov equations solving only eigen-problems of halved dimensionality. The class <code><a class="el" href="class_ultra_cold_1_1_bogolyubov_solvers_1_1_trapped_bogolyubov_solver.html" title="Class to solve the Bogolyubov equations for a trapped Bose gas.">UltraCold::BogolyubovSolvers::TrappedBogolyubovSolver</a></code> will do this automatically for us, provided that we feed a real Vector, representing the ground-state wave function, to its constructor. We thus first copy the calculated ground-state wave-function into a real-valued Vector</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="class_ultra_cold_1_1_vector.html">Vector&lt;double&gt;</a> psi0_real(nx,ny);</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; psi.size() ; ++i) psi0_real[i] = psi[i].real();</div>
</div><!-- fragment --><p >then initialize the data structures that will contain the solutions of the Bogolyubov equations</p>
<div class="fragment"><div class="line">std::vector&lt;std::complex&lt;double&gt;&gt; eigenvalues(number_of_modes);</div>
<div class="line">std::vector&lt; Vector&lt;std::complex&lt;double&gt;&gt; &gt; u(number_of_modes),v(number_of_modes);</div>
</div><!-- fragment --><p >and, finally, create our solver class and run the solver</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="class_ultra_cold_1_1_bogolyubov_solvers_1_1_trapped_bogolyubov_solver.html">BogolyubovSolvers::TrappedBogolyubovSolver</a> bdg_solver(x,</div>
<div class="line">                                                      y,</div>
<div class="line">                                                      psi0_real,</div>
<div class="line">                                                      Vext,</div>
<div class="line">                                                      scattering_length,</div>
<div class="line">                                                      chemical_potential,</div>
<div class="line">                                                      number_of_modes,</div>
<div class="line">                                                      tolerance,</div>
<div class="line">                                                      maximum_number_arnoldi_iterations,</div>
<div class="line">                                                      calculate_eigenvectors);</div>
<div class="line"> </div>
<div class="line">std::tie(eigenvalues,u,v) =  bdg_solver.run();</div>
<div class="ttc" id="aclass_ultra_cold_1_1_bogolyubov_solvers_1_1_trapped_bogolyubov_solver_html"><div class="ttname"><a href="class_ultra_cold_1_1_bogolyubov_solvers_1_1_trapped_bogolyubov_solver.html">UltraCold::BogolyubovSolvers::TrappedBogolyubovSolver</a></div><div class="ttdoc">Class to solve the Bogolyubov equations for a trapped Bose gas.</div><div class="ttdef"><b>Definition:</b> BogolyubovSolvers.hpp:134</div></div>
</div><!-- fragment --><p >In the context of Bogolyubov theory, several interesting properties can be extracted from the knowledge of \( u \) and \( v \). For example, one can see the density and phase fluctuations associated with each eigen-mode, by looking, respectively, at the quantities</p>
<p class="formulaDsp">
\[

\begin{align}

    &amp; \delta n({\bf r}) = (u({\bf r}) + v({\bf r}))\psi_0({\bf r}) \nonumber \\
    &amp; \delta \phi({\bf r}) = (u({\bf r}) - v({\bf r}))/\psi_0({\bf r}) \nonumber \\

\end{align}

\]
</p>
<p >This is exactly what we calculated and output into some .vtk files with the last lines of the example</p>
<div class="fragment"><div class="line">    <a class="code hl_class" href="class_ultra_cold_1_1_graphic_output_1_1_data_writer.html">GraphicOutput::DataWriter</a>                    output_fluctuations;</div>
<div class="line">    std::vector&lt;Vector&lt; std::complex&lt;double&gt;&gt; &gt; density_fluctuations(number_of_modes);</div>
<div class="line">    std::vector&lt;Vector&lt; std::complex&lt;double&gt;&gt; &gt; phase_fluctuations(number_of_modes);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; number_of_modes; ++i)</div>
<div class="line">    {</div>
<div class="line"> </div>
<div class="line">        std::cout &lt;&lt; eigenvalues[i].real() &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; eigenvalues[i].imag() &lt;&lt; std::endl;</div>
<div class="line">        density_fluctuations[i].reinit(nx, ny);</div>
<div class="line">        phase_fluctuations[i].reinit(nx, ny);</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; nx * ny; ++j)</div>
<div class="line">        {</div>
<div class="line">            density_fluctuations[i](j) = (u[i](j) + v[i](j)) * psi0_real(j);</div>
<div class="line">            phase_fluctuations[i](j)   = (u[i](j) - v[i](j)) / psi0_real(j);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        output_fluctuations.<a class="code hl_function" href="class_ultra_cold_1_1_graphic_output_1_1_data_writer.html#a5379ac7b98c084855b372e863c095856">set_output_name</a>(<span class="stringliteral">&quot;density_fluctuations_mode_&quot;</span> + std::to_string(i));</div>
<div class="line">        output_fluctuations.<a class="code hl_function" href="class_ultra_cold_1_1_graphic_output_1_1_data_writer.html#aec73552d1a4ccd5f3111c6268961279b">write_vtk</a>(x, y, density_fluctuations[i], <span class="stringliteral">&quot;density_fluctuations&quot;</span>,<span class="stringliteral">&quot;ASCII&quot;</span>);</div>
<div class="line"> </div>
<div class="line">        output_fluctuations.<a class="code hl_function" href="class_ultra_cold_1_1_graphic_output_1_1_data_writer.html#a5379ac7b98c084855b372e863c095856">set_output_name</a>(<span class="stringliteral">&quot;phase_fluctuations_mode_&quot;</span> + std::to_string(i));</div>
<div class="line">        output_fluctuations.<a class="code hl_function" href="class_ultra_cold_1_1_graphic_output_1_1_data_writer.html#aec73552d1a4ccd5f3111c6268961279b">write_vtk</a>(x, y, phase_fluctuations[i], <span class="stringliteral">&quot;phase_fluctuations&quot;</span>,<span class="stringliteral">&quot;ASCII&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line"> </div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="Results-2"></a>
Results</h2>
<p >The output of the program related to the (first) calculated eigenvalues, corresponding to the energies of the Bogolyubov modes in units of \( \hbar \omega_{ho} \), is the following:</p>
<pre class="fragment">1.6365e-06 0
0.999999 0
0.999999 0
1.41758 0
1.41758 0
1.74505 0
1.74505 0
2 0
2.03118 0
2.03118 0
2.29579 0
2.29579 0</pre><p >Notice the presence of the two dipole modes, with a frequency approximately equal to one, representing the "sloshing" oscillations of the center of mass of the cloud along the x and y directions, and <b>always</b> present in the presence of harmonic trapping, as well as the presence of the characteristic <em>breathing</em> oscillation which, for this type of gas, has a frequency equal to \( 2\omega_{ho} \). Notice also that all the modes are twice degenerate.</p>
<p >We can also have a look at the ground-state density profile, as well as the density and phase fluctuations, plotted from the .vtk output using again Paraview:</p>
<div class="image">
<img src="example-2-fig.png" alt="" width="50%"/>
</div>
<p >We see that most of the modes are surface modes with different angular momenta, while the breathing mode (the fifth mode in order from top to bottom, with the frequency of \( 2\omega_{ho} \)) has clearly a compressional character.</p>
<h2><a class="anchor" id="Uncommented-2"></a>
The plain program</h2>
<div class="fragment"><div class="line"><span class="comment">/*--------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> *    This file is part of the UltraCold project.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> *    UltraCold is free software: you can redistribute it and/or modify</span></div>
<div class="line"><span class="comment"> *    it under the terms of the GNU General Public License as published by</span></div>
<div class="line"><span class="comment"> *    the Free Software Foundation, either version 3 of the License, or</span></div>
<div class="line"><span class="comment"> *    any later version.</span></div>
<div class="line"><span class="comment"> *    UltraCold is distributed in the hope that it will be useful,</span></div>
<div class="line"><span class="comment"> *    but WITHOUT ANY WARRANTY; without even the implied warranty of</span></div>
<div class="line"><span class="comment"> *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span></div>
<div class="line"><span class="comment"> *    GNU General Public License for more details.</span></div>
<div class="line"><span class="comment"> *    You should have received a copy of the GNU General Public License</span></div>
<div class="line"><span class="comment"> *    along with UltraCold.  If not, see &lt;https://www.gnu.org/licenses/&gt;.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> *--------------------------------------------------------------------------------*/</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;UltraCold.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespace_ultra_cold.html">UltraCold</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_ultra_cold_1_1_tools_1_1_input_parser.html">Tools::InputParser</a> ip(<span class="stringliteral">&quot;../example-2.prm&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    ip.read_input_file();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> xmax = ip.retrieve_double(<span class="stringliteral">&quot;xmax&quot;</span>);</div>
<div class="line">    <span class="keywordtype">double</span> ymax = ip.retrieve_double(<span class="stringliteral">&quot;ymax&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> nx = ip.retrieve_int(<span class="stringliteral">&quot;nx&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> ny = ip.retrieve_int(<span class="stringliteral">&quot;ny&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span>       scattering_length   = ip.retrieve_double(<span class="stringliteral">&quot;scattering length&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span>    number_of_particles = ip.retrieve_int(<span class="stringliteral">&quot;number of particles&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> atomic_mass         = ip.retrieve_double(<span class="stringliteral">&quot;atomic mass&quot;</span>);</div>
<div class="line">    <span class="keywordtype">double</span> omegax                    = ip.retrieve_double(<span class="stringliteral">&quot;omegax&quot;</span>);</div>
<div class="line">    <span class="keywordtype">double</span> omegay                    = ip.retrieve_double(<span class="stringliteral">&quot;omegay&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span>    number_of_gradient_descent_steps = ip.retrieve_int(<span class="stringliteral">&quot;number of gradient descent steps&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> residual                         = ip.retrieve_double(<span class="stringliteral">&quot;residual&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> alpha                            = ip.retrieve_double(<span class="stringliteral">&quot;alpha&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> beta                             = ip.retrieve_double(<span class="stringliteral">&quot;beta&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> number_of_modes = ip.retrieve_int(<span class="stringliteral">&quot;number of modes&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> maximum_number_arnoldi_iterations = ip.retrieve_int(<span class="stringliteral">&quot;maximum number of arnoldi iterations&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> tolerance = ip.retrieve_double(<span class="stringliteral">&quot;tolerance&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span> calculate_eigenvectors = ip.retrieve_bool(<span class="stringliteral">&quot;calculate eigenvectors&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> hbar        = 0.6347*1.E5;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> bohr_radius = 5.292E-5;</div>
<div class="line"> </div>
<div class="line">    omegax *= TWOPI;</div>
<div class="line">    omegay *= TWOPI;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> omega_ho = std::sqrt(omegax*omegay);</div>
<div class="line"> </div>
<div class="line">    omegax = omegax/omega_ho;</div>
<div class="line">    omegay = omegay/omega_ho;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> a_ho = std::sqrt(hbar/(atomic_mass*omega_ho));</div>
<div class="line"> </div>
<div class="line">    scattering_length   *= bohr_radius/a_ho;</div>
<div class="line"> </div>
<div class="line">    xmax = xmax/a_ho;</div>
<div class="line">    ymax = ymax/a_ho;</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_ultra_cold_1_1_vector.html">Vector&lt;double&gt;</a> x(nx);</div>
<div class="line">    <a class="code hl_class" href="class_ultra_cold_1_1_vector.html">Vector&lt;double&gt;</a> y(ny);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> dx = 2.*xmax/nx;</div>
<div class="line">    <span class="keywordtype">double</span> dy = 2.*ymax/ny;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; nx; ++i) x(i) = -xmax + i*dx;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; ny; ++i) y(i) = -ymax + i*dy;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> dv = dx*dy;</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_ultra_cold_1_1_vector.html">Vector&lt;std::complex&lt;double&gt;</a>&gt; psi(nx,ny);</div>
<div class="line">    <a class="code hl_class" href="class_ultra_cold_1_1_vector.html">Vector&lt;double&gt;</a> Vext(nx,ny);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; nx; ++i)</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; ny; ++j)</div>
<div class="line">            {</div>
<div class="line"> </div>
<div class="line">                psi(i,j)  = exp(- (pow(x(i),2) + pow(y(j),2)) );</div>
<div class="line"> </div>
<div class="line">                Vext(i,j) = 0.5*( std::pow(omegax,2)*pow(x(i),2) +</div>
<div class="line">                                  std::pow(omegay,2)*pow(y(j),2));</div>
<div class="line"> </div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> norm = 0.0;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; psi.size(); ++i) norm += std::norm(psi[i]);</div>
<div class="line">    norm *= dv;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; psi.size(); ++i) psi[i] *= std::sqrt(number_of_particles/norm);</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_ultra_cold_1_1_g_p_solvers_1_1_g_p_solver.html">GPSolvers::GPSolver</a> gp_solver(x,</div>
<div class="line">                                  y,</div>
<div class="line">                                  psi,</div>
<div class="line">                                  Vext,</div>
<div class="line">                                  scattering_length);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> chemical_potential;</div>
<div class="line">    std::tie(psi,chemical_potential) = gp_solver.run_gradient_descent(number_of_gradient_descent_steps,</div>
<div class="line">                                                                      residual,</div>
<div class="line">                                                                      alpha,</div>
<div class="line">                                                                      beta,</div>
<div class="line">                                                                      std::cout);</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_ultra_cold_1_1_graphic_output_1_1_data_writer.html">GraphicOutput::DataWriter</a> output_wave_function;</div>
<div class="line">    output_wave_function.<a class="code hl_function" href="class_ultra_cold_1_1_graphic_output_1_1_data_writer.html#a5379ac7b98c084855b372e863c095856">set_output_name</a>(<span class="stringliteral">&quot;ground_state_wave_function&quot;</span>);</div>
<div class="line">    output_wave_function.<a class="code hl_function" href="class_ultra_cold_1_1_graphic_output_1_1_data_writer.html#aec73552d1a4ccd5f3111c6268961279b">write_vtk</a>(x,y,psi,<span class="stringliteral">&quot;ground_state_wave_function&quot;</span>,<span class="stringliteral">&quot;ASCII&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_ultra_cold_1_1_vector.html">Vector&lt;double&gt;</a> psi0_real(nx,ny);</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; psi.size() ; ++i) psi0_real[i] = psi[i].real();</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;std::complex&lt;double&gt;&gt; eigenvalues(number_of_modes);</div>
<div class="line">    std::vector&lt; Vector&lt;std::complex&lt;double&gt;&gt; &gt; u(number_of_modes),v(number_of_modes);</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_ultra_cold_1_1_bogolyubov_solvers_1_1_trapped_bogolyubov_solver.html">BogolyubovSolvers::TrappedBogolyubovSolver</a> bdg_solver(x,</div>
<div class="line">                                                          y,</div>
<div class="line">                                                          psi0_real,</div>
<div class="line">                                                          Vext,</div>
<div class="line">                                                          scattering_length,</div>
<div class="line">                                                          chemical_potential,</div>
<div class="line">                                                          number_of_modes,</div>
<div class="line">                                                          tolerance,</div>
<div class="line">                                                          maximum_number_arnoldi_iterations,</div>
<div class="line">                                                          calculate_eigenvectors);</div>
<div class="line"> </div>
<div class="line">    std::tie(eigenvalues,u,v) =  bdg_solver.run();</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_ultra_cold_1_1_graphic_output_1_1_data_writer.html">GraphicOutput::DataWriter</a>                    output_fluctuations;</div>
<div class="line">    std::vector&lt;Vector&lt; std::complex&lt;double&gt;&gt; &gt; density_fluctuations(number_of_modes);</div>
<div class="line">    std::vector&lt;Vector&lt; std::complex&lt;double&gt;&gt; &gt; phase_fluctuations(number_of_modes);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; number_of_modes; ++i)</div>
<div class="line">    {</div>
<div class="line"> </div>
<div class="line">        std::cout &lt;&lt; eigenvalues[i].real() &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; eigenvalues[i].imag() &lt;&lt; std::endl;</div>
<div class="line">        density_fluctuations[i].reinit(nx, ny);</div>
<div class="line">        phase_fluctuations[i].reinit(nx, ny);</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; nx * ny; ++j)</div>
<div class="line">        {</div>
<div class="line">            density_fluctuations[i](j) = (u[i](j) + v[i](j)) * psi0_real(j);</div>
<div class="line">            phase_fluctuations[i](j)   = (u[i](j) - v[i](j)) / psi0_real(j);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        output_fluctuations.<a class="code hl_function" href="class_ultra_cold_1_1_graphic_output_1_1_data_writer.html#a5379ac7b98c084855b372e863c095856">set_output_name</a>(<span class="stringliteral">&quot;density_fluctuations_mode_&quot;</span> + std::to_string(i));</div>
<div class="line">        output_fluctuations.<a class="code hl_function" href="class_ultra_cold_1_1_graphic_output_1_1_data_writer.html#aec73552d1a4ccd5f3111c6268961279b">write_vtk</a>(x, y, density_fluctuations[i], <span class="stringliteral">&quot;density_fluctuations&quot;</span>,<span class="stringliteral">&quot;ASCII&quot;</span>);</div>
<div class="line"> </div>
<div class="line">        output_fluctuations.<a class="code hl_function" href="class_ultra_cold_1_1_graphic_output_1_1_data_writer.html#a5379ac7b98c084855b372e863c095856">set_output_name</a>(<span class="stringliteral">&quot;phase_fluctuations_mode_&quot;</span> + std::to_string(i));</div>
<div class="line">        output_fluctuations.<a class="code hl_function" href="class_ultra_cold_1_1_graphic_output_1_1_data_writer.html#aec73552d1a4ccd5f3111c6268961279b">write_vtk</a>(x, y, phase_fluctuations[i], <span class="stringliteral">&quot;phase_fluctuations&quot;</span>,<span class="stringliteral">&quot;ASCII&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line"> </div>
<div class="line">}</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
