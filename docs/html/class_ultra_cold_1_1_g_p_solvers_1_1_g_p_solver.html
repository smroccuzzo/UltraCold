<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>UltraCold: UltraCold::GPSolvers::GPSolver Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/SVG"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">UltraCold
   </div>
   <div id="projectbrief">Collection of C++ libraries for the study of ultra-cold systems in the context of Gross-Pitaevskii theory</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_ultra_cold_1_1_g_p_solvers_1_1_g_p_solver.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="class_ultra_cold_1_1_g_p_solvers_1_1_g_p_solver-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">UltraCold::GPSolvers::GPSolver Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Class to solve the Gross-Pitaevskii equation.  
 <a href="class_ultra_cold_1_1_g_p_solvers_1_1_g_p_solver.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_g_p_solvers_8hpp_source.html">GPSolvers.hpp</a>&gt;</code></p>

<p>Inherited by <a class="el" href="classmy_g_p_solver.html">myGPSolver</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a27e4ed4915c1e2bfcabb82c2d7d07af0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ultra_cold_1_1_g_p_solvers_1_1_g_p_solver.html#a27e4ed4915c1e2bfcabb82c2d7d07af0">GPSolver</a> (<a class="el" href="class_ultra_cold_1_1_vector.html">Vector</a>&lt; double &gt; &amp;x, <a class="el" href="class_ultra_cold_1_1_vector.html">Vector</a>&lt; std::complex&lt; double &gt; &gt; &amp;psi_0, <a class="el" href="class_ultra_cold_1_1_vector.html">Vector</a>&lt; double &gt; &amp;Vext, double scattering_length)</td></tr>
<tr class="memdesc:a27e4ed4915c1e2bfcabb82c2d7d07af0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for a <a class="el" href="class_ultra_cold_1_1_g_p_solvers_1_1_g_p_solver.html" title="Class to solve the Gross-Pitaevskii equation.">GPSolver</a> in one space dimension.  <a href="class_ultra_cold_1_1_g_p_solvers_1_1_g_p_solver.html#a27e4ed4915c1e2bfcabb82c2d7d07af0">More...</a><br /></td></tr>
<tr class="separator:a27e4ed4915c1e2bfcabb82c2d7d07af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00ae80a9fb6fe441c455ddc7d1b45df5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ultra_cold_1_1_g_p_solvers_1_1_g_p_solver.html#a00ae80a9fb6fe441c455ddc7d1b45df5">GPSolver</a> (<a class="el" href="class_ultra_cold_1_1_vector.html">Vector</a>&lt; double &gt; &amp;x, <a class="el" href="class_ultra_cold_1_1_vector.html">Vector</a>&lt; double &gt; &amp;y, <a class="el" href="class_ultra_cold_1_1_vector.html">Vector</a>&lt; std::complex&lt; double &gt; &gt; &amp;psi_0, <a class="el" href="class_ultra_cold_1_1_vector.html">Vector</a>&lt; double &gt; &amp;Vext, double scattering_length)</td></tr>
<tr class="memdesc:a00ae80a9fb6fe441c455ddc7d1b45df5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for a <a class="el" href="class_ultra_cold_1_1_g_p_solvers_1_1_g_p_solver.html" title="Class to solve the Gross-Pitaevskii equation.">GPSolver</a> in two space dimensions.  <a href="class_ultra_cold_1_1_g_p_solvers_1_1_g_p_solver.html#a00ae80a9fb6fe441c455ddc7d1b45df5">More...</a><br /></td></tr>
<tr class="separator:a00ae80a9fb6fe441c455ddc7d1b45df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada67b8cb4973130f71e25058f4225791"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ultra_cold_1_1_g_p_solvers_1_1_g_p_solver.html#ada67b8cb4973130f71e25058f4225791">GPSolver</a> (<a class="el" href="class_ultra_cold_1_1_vector.html">Vector</a>&lt; double &gt; &amp;x, <a class="el" href="class_ultra_cold_1_1_vector.html">Vector</a>&lt; double &gt; &amp;y, <a class="el" href="class_ultra_cold_1_1_vector.html">Vector</a>&lt; double &gt; &amp;z, <a class="el" href="class_ultra_cold_1_1_vector.html">Vector</a>&lt; std::complex&lt; double &gt; &gt; &amp;psi_0, <a class="el" href="class_ultra_cold_1_1_vector.html">Vector</a>&lt; double &gt; &amp;Vext, double scattering_length)</td></tr>
<tr class="memdesc:ada67b8cb4973130f71e25058f4225791"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for a <a class="el" href="class_ultra_cold_1_1_g_p_solvers_1_1_g_p_solver.html" title="Class to solve the Gross-Pitaevskii equation.">GPSolver</a> in three space dimensions.  <a href="class_ultra_cold_1_1_g_p_solvers_1_1_g_p_solver.html#ada67b8cb4973130f71e25058f4225791">More...</a><br /></td></tr>
<tr class="separator:ada67b8cb4973130f71e25058f4225791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25266cb9ac54c8d7faed86fc2eb987b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ultra_cold_1_1_g_p_solvers_1_1_g_p_solver.html#a25266cb9ac54c8d7faed86fc2eb987b4">reinit</a> (<a class="el" href="class_ultra_cold_1_1_vector.html">Vector</a>&lt; double &gt; &amp;Vext, <a class="el" href="class_ultra_cold_1_1_vector.html">Vector</a>&lt; std::complex&lt; double &gt; &gt; &amp;psi_0)</td></tr>
<tr class="memdesc:a25266cb9ac54c8d7faed86fc2eb987b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reinitialize the solver with new external potential and initial condition.  <a href="class_ultra_cold_1_1_g_p_solvers_1_1_g_p_solver.html#a25266cb9ac54c8d7faed86fc2eb987b4">More...</a><br /></td></tr>
<tr class="separator:a25266cb9ac54c8d7faed86fc2eb987b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa52ead6af5a33d5bd9d3ad75ef66763b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ultra_cold_1_1_g_p_solvers_1_1_g_p_solver.html#aa52ead6af5a33d5bd9d3ad75ef66763b">reinit</a> (<a class="el" href="class_ultra_cold_1_1_vector.html">Vector</a>&lt; double &gt; &amp;Vext, <a class="el" href="class_ultra_cold_1_1_vector.html">Vector</a>&lt; std::complex&lt; double &gt; &gt; &amp;psi_0, double scattering_length)</td></tr>
<tr class="memdesc:aa52ead6af5a33d5bd9d3ad75ef66763b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reinitialize the solver with new external potential and initial condition.  <a href="class_ultra_cold_1_1_g_p_solvers_1_1_g_p_solver.html#aa52ead6af5a33d5bd9d3ad75ef66763b">More...</a><br /></td></tr>
<tr class="separator:aa52ead6af5a33d5bd9d3ad75ef66763b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84345a4d4b14ccc40bc83b170fea7eff"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="class_ultra_cold_1_1_vector.html">Vector</a>&lt; std::complex&lt; double &gt; &gt;, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ultra_cold_1_1_g_p_solvers_1_1_g_p_solver.html#a84345a4d4b14ccc40bc83b170fea7eff">run_gradient_descent</a> (<a class="el" href="classint.html">int</a> max_num_iter, double tolerance, double alpha, double beta, std::ostream &amp;output_stream, <a class="el" href="classint.html">int</a> write_output_every)</td></tr>
<tr class="memdesc:a84345a4d4b14ccc40bc83b170fea7eff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a ground-state solution to the stationary Gross-Pitaevskii equation.  <a href="class_ultra_cold_1_1_g_p_solvers_1_1_g_p_solver.html#a84345a4d4b14ccc40bc83b170fea7eff">More...</a><br /></td></tr>
<tr class="separator:a84345a4d4b14ccc40bc83b170fea7eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6788cfe66df9122fb9088258a9649862"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ultra_cold_1_1_g_p_solvers_1_1_g_p_solver.html#a6788cfe66df9122fb9088258a9649862">run_operator_splitting</a> (<a class="el" href="classint.html">int</a> number_of_time_steps, double time_step, std::ostream &amp;output_stream, <a class="el" href="classint.html">int</a> write_output_every)</td></tr>
<tr class="memdesc:a6788cfe66df9122fb9088258a9649862"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the Gross-Pitaevskii equation using simple operator splitting.  <a href="class_ultra_cold_1_1_g_p_solvers_1_1_g_p_solver.html#a6788cfe66df9122fb9088258a9649862">More...</a><br /></td></tr>
<tr class="separator:a6788cfe66df9122fb9088258a9649862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3631a396572e099006074d014392c4ae"><td class="memItemLeft" align="right" valign="top"><a id="a3631a396572e099006074d014392c4ae" name="a3631a396572e099006074d014392c4ae"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>run_operator_splitting</b> (<a class="el" href="classint.html">int</a>, double, double, std::ostream &amp;, <a class="el" href="classint.html">int</a>)</td></tr>
<tr class="memdesc:a3631a396572e099006074d014392c4ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Useful possible overload. <br /></td></tr>
<tr class="separator:a3631a396572e099006074d014392c4ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb817e25ada97df704e048175ae152c0"><td class="memItemLeft" align="right" valign="top"><a id="acb817e25ada97df704e048175ae152c0" name="acb817e25ada97df704e048175ae152c0"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>run_operator_splitting</b> (<a class="el" href="classint.html">int</a>, double, double, double, std::ostream &amp;, <a class="el" href="classint.html">int</a>)</td></tr>
<tr class="memdesc:acb817e25ada97df704e048175ae152c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Useful possible overload. <br /></td></tr>
<tr class="separator:acb817e25ada97df704e048175ae152c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af97a826c7f530c7768794b9f5df3d738"><td class="memItemLeft" align="right" valign="top"><a id="af97a826c7f530c7768794b9f5df3d738" name="af97a826c7f530c7768794b9f5df3d738"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>run_operator_splitting</b> (<a class="el" href="classint.html">int</a>, double, double, double, double, std::ostream &amp;, <a class="el" href="classint.html">int</a>)</td></tr>
<tr class="memdesc:af97a826c7f530c7768794b9f5df3d738"><td class="mdescLeft">&#160;</td><td class="mdescRight">Useful possible overload. <br /></td></tr>
<tr class="separator:af97a826c7f530c7768794b9f5df3d738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52ef3dbf3041aa314cf61f24e086129a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ultra_cold_1_1_g_p_solvers_1_1_g_p_solver.html#a52ef3dbf3041aa314cf61f24e086129a">set_tw_initial_conditions</a> (bool system_is_in_harmonic_trap, bool first_call, <a class="el" href="classint.html">int</a> number_of_modes)</td></tr>
<tr class="memdesc:a52ef3dbf3041aa314cf61f24e086129a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set initial conditions for a run in the context of the Truncated Wigner Approximation.  <a href="class_ultra_cold_1_1_g_p_solvers_1_1_g_p_solver.html#a52ef3dbf3041aa314cf61f24e086129a">More...</a><br /></td></tr>
<tr class="separator:a52ef3dbf3041aa314cf61f24e086129a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a622bd85894d716dcabe1778d08e6dad3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ultra_cold_1_1_g_p_solvers_1_1_g_p_solver.html#a622bd85894d716dcabe1778d08e6dad3">write_gradient_descent_output</a> (size_t iteration_number, std::ostream &amp;output_stream)</td></tr>
<tr class="memdesc:a622bd85894d716dcabe1778d08e6dad3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write output at each step of the gradient descent iterations.  <a href="class_ultra_cold_1_1_g_p_solvers_1_1_g_p_solver.html#a622bd85894d716dcabe1778d08e6dad3">More...</a><br /></td></tr>
<tr class="separator:a622bd85894d716dcabe1778d08e6dad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac55d1c9f9408d67cac7da7c5b734519a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ultra_cold_1_1_g_p_solvers_1_1_g_p_solver.html#ac55d1c9f9408d67cac7da7c5b734519a">write_operator_splitting_output</a> (size_t iteration_number, std::ostream &amp;output_stream)</td></tr>
<tr class="memdesc:ac55d1c9f9408d67cac7da7c5b734519a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write some output at each time step.  <a href="class_ultra_cold_1_1_g_p_solvers_1_1_g_p_solver.html#ac55d1c9f9408d67cac7da7c5b734519a">More...</a><br /></td></tr>
<tr class="separator:ac55d1c9f9408d67cac7da7c5b734519a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a74fe7c72978a6d0472cd3818b119cb"><td class="memItemLeft" align="right" valign="top"><a id="a6a74fe7c72978a6d0472cd3818b119cb" name="a6a74fe7c72978a6d0472cd3818b119cb"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>write_operator_splitting_output</b> (size_t, size_t, std::ostream &amp;)</td></tr>
<tr class="memdesc:a6a74fe7c72978a6d0472cd3818b119cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Useful possible overload. <br /></td></tr>
<tr class="separator:a6a74fe7c72978a6d0472cd3818b119cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fead0fe846e939e6de4a5807f604796"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ultra_cold_1_1_g_p_solvers_1_1_g_p_solver.html#a5fead0fe846e939e6de4a5807f604796">write_operator_splitting_output</a> (size_t, double, std::ostream &amp;)</td></tr>
<tr class="memdesc:a5fead0fe846e939e6de4a5807f604796"><td class="mdescLeft">&#160;</td><td class="mdescRight">Useful possible overload.  <a href="class_ultra_cold_1_1_g_p_solvers_1_1_g_p_solver.html#a5fead0fe846e939e6de4a5807f604796">More...</a><br /></td></tr>
<tr class="separator:a5fead0fe846e939e6de4a5807f604796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf425e6acdd2062e897aa44e3f808e70"><td class="memItemLeft" align="right" valign="top"><a id="acf425e6acdd2062e897aa44e3f808e70" name="acf425e6acdd2062e897aa44e3f808e70"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>write_operator_splitting_output</b> (size_t, double, double, std::ostream &amp;)</td></tr>
<tr class="memdesc:acf425e6acdd2062e897aa44e3f808e70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Useful possible overload. <br /></td></tr>
<tr class="separator:acf425e6acdd2062e897aa44e3f808e70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a272bc497630e88301e1d38a9d25d1930"><td class="memItemLeft" align="right" valign="top"><a id="a272bc497630e88301e1d38a9d25d1930" name="a272bc497630e88301e1d38a9d25d1930"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>write_operator_splitting_output</b> (size_t, double, double, double, std::ostream &amp;)</td></tr>
<tr class="memdesc:a272bc497630e88301e1d38a9d25d1930"><td class="mdescLeft">&#160;</td><td class="mdescRight">Useful possible overload. <br /></td></tr>
<tr class="separator:a272bc497630e88301e1d38a9d25d1930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86695841c57f5a9a0eb05c9876babf15"><td class="memItemLeft" align="right" valign="top"><a id="a86695841c57f5a9a0eb05c9876babf15" name="a86695841c57f5a9a0eb05c9876babf15"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>solve_step_1_operator_splitting</b> ()</td></tr>
<tr class="memdesc:a86695841c57f5a9a0eb05c9876babf15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve step-1 of operator splitting. <br /></td></tr>
<tr class="separator:a86695841c57f5a9a0eb05c9876babf15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63f42a4712185f1b03d7bd45e1525854"><td class="memItemLeft" align="right" valign="top"><a id="a63f42a4712185f1b03d7bd45e1525854" name="a63f42a4712185f1b03d7bd45e1525854"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>solve_step_1_operator_splitting</b> (<a class="el" href="classint.html">int</a>)</td></tr>
<tr class="memdesc:a63f42a4712185f1b03d7bd45e1525854"><td class="mdescLeft">&#160;</td><td class="mdescRight">Useful possible overload. <br /></td></tr>
<tr class="separator:a63f42a4712185f1b03d7bd45e1525854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5723859b9d1ab0b9b1bd10a861fd56d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ultra_cold_1_1_g_p_solvers_1_1_g_p_solver.html#af5723859b9d1ab0b9b1bd10a861fd56d">solve_step_1_operator_splitting</a> (double)</td></tr>
<tr class="memdesc:af5723859b9d1ab0b9b1bd10a861fd56d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Useful possible overload.  <a href="class_ultra_cold_1_1_g_p_solvers_1_1_g_p_solver.html#af5723859b9d1ab0b9b1bd10a861fd56d">More...</a><br /></td></tr>
<tr class="separator:af5723859b9d1ab0b9b1bd10a861fd56d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea6acde99a74bc9af339f835cf7cbe1f"><td class="memItemLeft" align="right" valign="top"><a id="aea6acde99a74bc9af339f835cf7cbe1f" name="aea6acde99a74bc9af339f835cf7cbe1f"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>solve_step_1_operator_splitting</b> (double, double)</td></tr>
<tr class="memdesc:aea6acde99a74bc9af339f835cf7cbe1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Useful possible overload. <br /></td></tr>
<tr class="separator:aea6acde99a74bc9af339f835cf7cbe1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43dfbd4d4c7e231677a7dc41feabc3c5"><td class="memItemLeft" align="right" valign="top"><a id="a43dfbd4d4c7e231677a7dc41feabc3c5" name="a43dfbd4d4c7e231677a7dc41feabc3c5"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>solve_step_1_operator_splitting</b> (double, double, double)</td></tr>
<tr class="memdesc:a43dfbd4d4c7e231677a7dc41feabc3c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Useful possible overload. <br /></td></tr>
<tr class="separator:a43dfbd4d4c7e231677a7dc41feabc3c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89dd0f90d9f3db9cbee73b388389b9b4"><td class="memItemLeft" align="right" valign="top"><a id="a89dd0f90d9f3db9cbee73b388389b9b4" name="a89dd0f90d9f3db9cbee73b388389b9b4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>solve_step_2_operator_splitting</b> (<a class="el" href="class_ultra_cold_1_1_m_k_l_wrappers_1_1_d_ft_calculator.html">MKLWrappers::DFtCalculator</a> &amp;)</td></tr>
<tr class="memdesc:a89dd0f90d9f3db9cbee73b388389b9b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve step-2 of operator splitting. <br /></td></tr>
<tr class="separator:a89dd0f90d9f3db9cbee73b388389b9b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a48398e3df8d5c2bc187242e9c932dd42"><td class="memItemLeft" align="right" valign="top"><a id="a48398e3df8d5c2bc187242e9c932dd42" name="a48398e3df8d5c2bc187242e9c932dd42"></a>
<a class="el" href="class_ultra_cold_1_1_vector.html">Vector</a>&lt; std::complex&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>psi</b></td></tr>
<tr class="separator:a48398e3df8d5c2bc187242e9c932dd42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9db02467eaa8220c1fcb38b1e244fe80"><td class="memItemLeft" align="right" valign="top"><a id="a9db02467eaa8220c1fcb38b1e244fe80" name="a9db02467eaa8220c1fcb38b1e244fe80"></a>
<a class="el" href="class_ultra_cold_1_1_vector.html">Vector</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Vext</b></td></tr>
<tr class="separator:a9db02467eaa8220c1fcb38b1e244fe80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a552caa2b0539f887366f4482cfc95b"><td class="memItemLeft" align="right" valign="top"><a id="a3a552caa2b0539f887366f4482cfc95b" name="a3a552caa2b0539f887366f4482cfc95b"></a>
<a class="el" href="class_ultra_cold_1_1_vector.html">Vector</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>x</b></td></tr>
<tr class="separator:a3a552caa2b0539f887366f4482cfc95b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee6e71813f59a2913093f8a4953b2941"><td class="memItemLeft" align="right" valign="top"><a id="aee6e71813f59a2913093f8a4953b2941" name="aee6e71813f59a2913093f8a4953b2941"></a>
<a class="el" href="class_ultra_cold_1_1_vector.html">Vector</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>y</b></td></tr>
<tr class="separator:aee6e71813f59a2913093f8a4953b2941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7cd95d4d0720058bab9eb03141d37d9"><td class="memItemLeft" align="right" valign="top"><a id="ae7cd95d4d0720058bab9eb03141d37d9" name="ae7cd95d4d0720058bab9eb03141d37d9"></a>
<a class="el" href="class_ultra_cold_1_1_vector.html">Vector</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>z</b></td></tr>
<tr class="separator:ae7cd95d4d0720058bab9eb03141d37d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5830ec77a98a458045cb33c9f0ca6d5"><td class="memItemLeft" align="right" valign="top"><a id="ae5830ec77a98a458045cb33c9f0ca6d5" name="ae5830ec77a98a458045cb33c9f0ca6d5"></a>
<a class="el" href="class_ultra_cold_1_1_vector.html">Vector</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>kx</b></td></tr>
<tr class="separator:ae5830ec77a98a458045cb33c9f0ca6d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fcc5f45722fdd2cc046153306dc20f5"><td class="memItemLeft" align="right" valign="top"><a id="a4fcc5f45722fdd2cc046153306dc20f5" name="a4fcc5f45722fdd2cc046153306dc20f5"></a>
<a class="el" href="class_ultra_cold_1_1_vector.html">Vector</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ky</b></td></tr>
<tr class="separator:a4fcc5f45722fdd2cc046153306dc20f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a323a9d62567b559d0333a1a3924c1298"><td class="memItemLeft" align="right" valign="top"><a id="a323a9d62567b559d0333a1a3924c1298" name="a323a9d62567b559d0333a1a3924c1298"></a>
<a class="el" href="class_ultra_cold_1_1_vector.html">Vector</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>kz</b></td></tr>
<tr class="separator:a323a9d62567b559d0333a1a3924c1298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeaa7e665a2c9cd29229e2ed543c21ab"><td class="memItemLeft" align="right" valign="top"><a id="abeaa7e665a2c9cd29229e2ed543c21ab" name="abeaa7e665a2c9cd29229e2ed543c21ab"></a>
<a class="el" href="class_ultra_cold_1_1_vector.html">Vector</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>kmod2</b></td></tr>
<tr class="separator:abeaa7e665a2c9cd29229e2ed543c21ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca645a7df4ef31f9f8470cd93fae1de6"><td class="memItemLeft" align="right" valign="top"><a id="aca645a7df4ef31f9f8470cd93fae1de6" name="aca645a7df4ef31f9f8470cd93fae1de6"></a>
<a class="el" href="class_ultra_cold_1_1_vector.html">Vector</a>&lt; std::complex&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>psitilde</b></td></tr>
<tr class="separator:aca645a7df4ef31f9f8470cd93fae1de6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1872a692c26a825aa861f56ea6134418"><td class="memItemLeft" align="right" valign="top"><a id="a1872a692c26a825aa861f56ea6134418" name="a1872a692c26a825aa861f56ea6134418"></a>
<a class="el" href="class_ultra_cold_1_1_vector.html">Vector</a>&lt; std::complex&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>hpsi</b></td></tr>
<tr class="separator:a1872a692c26a825aa861f56ea6134418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a426915892c8f84d0144532d6a1f7c332"><td class="memItemLeft" align="right" valign="top"><a id="a426915892c8f84d0144532d6a1f7c332" name="a426915892c8f84d0144532d6a1f7c332"></a>
<a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><b>nx</b></td></tr>
<tr class="separator:a426915892c8f84d0144532d6a1f7c332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f662a8d81e6ae44731e1b8e29363dd3"><td class="memItemLeft" align="right" valign="top"><a id="a8f662a8d81e6ae44731e1b8e29363dd3" name="a8f662a8d81e6ae44731e1b8e29363dd3"></a>
<a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ny</b></td></tr>
<tr class="separator:a8f662a8d81e6ae44731e1b8e29363dd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a690e513896b1fc552cf7d356e8469278"><td class="memItemLeft" align="right" valign="top"><a id="a690e513896b1fc552cf7d356e8469278" name="a690e513896b1fc552cf7d356e8469278"></a>
<a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><b>nz</b></td></tr>
<tr class="separator:a690e513896b1fc552cf7d356e8469278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2480bd73aba78e3ae9f5b10f483747e"><td class="memItemLeft" align="right" valign="top"><a id="ae2480bd73aba78e3ae9f5b10f483747e" name="ae2480bd73aba78e3ae9f5b10f483747e"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>dx</b> = 1.0</td></tr>
<tr class="separator:ae2480bd73aba78e3ae9f5b10f483747e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4150cadaa2944849c1303eb7910a93f8"><td class="memItemLeft" align="right" valign="top"><a id="a4150cadaa2944849c1303eb7910a93f8" name="a4150cadaa2944849c1303eb7910a93f8"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>dy</b> = 1.0</td></tr>
<tr class="separator:a4150cadaa2944849c1303eb7910a93f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45327bc460252ad119a2e1e8106f072a"><td class="memItemLeft" align="right" valign="top"><a id="a45327bc460252ad119a2e1e8106f072a" name="a45327bc460252ad119a2e1e8106f072a"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>dz</b> = 1.0</td></tr>
<tr class="separator:a45327bc460252ad119a2e1e8106f072a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab823dae983fc3a89adcf8242709627c8"><td class="memItemLeft" align="right" valign="top"><a id="ab823dae983fc3a89adcf8242709627c8" name="ab823dae983fc3a89adcf8242709627c8"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>dv</b> = 1.0</td></tr>
<tr class="separator:ab823dae983fc3a89adcf8242709627c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdd8b81132f9bba3bd0de032d33d3a25"><td class="memItemLeft" align="right" valign="top"><a id="acdd8b81132f9bba3bd0de032d33d3a25" name="acdd8b81132f9bba3bd0de032d33d3a25"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>chemical_potential</b></td></tr>
<tr class="separator:acdd8b81132f9bba3bd0de032d33d3a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a248f4e22f4341cf8b4881b6adcaf6d24"><td class="memItemLeft" align="right" valign="top"><a id="a248f4e22f4341cf8b4881b6adcaf6d24" name="a248f4e22f4341cf8b4881b6adcaf6d24"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>scattering_length</b></td></tr>
<tr class="separator:a248f4e22f4341cf8b4881b6adcaf6d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81277607a5e3af058dd568c25e0b3fd9"><td class="memItemLeft" align="right" valign="top"><a id="a81277607a5e3af058dd568c25e0b3fd9" name="a81277607a5e3af058dd568c25e0b3fd9"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>residual</b></td></tr>
<tr class="separator:a81277607a5e3af058dd568c25e0b3fd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06d78d3cb9f3296062b9c145f176dc87"><td class="memItemLeft" align="right" valign="top"><a id="a06d78d3cb9f3296062b9c145f176dc87" name="a06d78d3cb9f3296062b9c145f176dc87"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>initial_norm</b></td></tr>
<tr class="separator:a06d78d3cb9f3296062b9c145f176dc87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaac8b4461671da1d7a7357eeb8f94b2f"><td class="memItemLeft" align="right" valign="top"><a id="aaac8b4461671da1d7a7357eeb8f94b2f" name="aaac8b4461671da1d7a7357eeb8f94b2f"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>norm</b></td></tr>
<tr class="separator:aaac8b4461671da1d7a7357eeb8f94b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fe4b6f916a22c8d64dc78f4573336e2"><td class="memItemLeft" align="right" valign="top"><a id="a5fe4b6f916a22c8d64dc78f4573336e2" name="a5fe4b6f916a22c8d64dc78f4573336e2"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>time_step</b></td></tr>
<tr class="separator:a5fe4b6f916a22c8d64dc78f4573336e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab47106be0800f38bf3bcd6c982c5497c"><td class="memItemLeft" align="right" valign="top"><a id="ab47106be0800f38bf3bcd6c982c5497c" name="ab47106be0800f38bf3bcd6c982c5497c"></a>
std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ci</b> ={0.0,1.0}</td></tr>
<tr class="separator:ab47106be0800f38bf3bcd6c982c5497c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc5d0d75e7499158277e01eaf0afc430"><td class="memItemLeft" align="right" valign="top"><a id="adc5d0d75e7499158277e01eaf0afc430" name="adc5d0d75e7499158277e01eaf0afc430"></a>
<a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><b>last_iteration_number</b></td></tr>
<tr class="separator:adc5d0d75e7499158277e01eaf0afc430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a31a276ad3e4773e1184d4bda427d92"><td class="memItemLeft" align="right" valign="top"><a id="a4a31a276ad3e4773e1184d4bda427d92" name="a4a31a276ad3e4773e1184d4bda427d92"></a>
<a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><b>write_output_every</b></td></tr>
<tr class="separator:a4a31a276ad3e4773e1184d4bda427d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2918befafc51304a3ab89e4cb096b25a"><td class="memItemLeft" align="right" valign="top"><a id="a2918befafc51304a3ab89e4cb096b25a" name="a2918befafc51304a3ab89e4cb096b25a"></a>
std::vector&lt; <a class="el" href="class_ultra_cold_1_1_vector.html">Vector</a>&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>eigenstates_harmonic_oscillator</b></td></tr>
<tr class="separator:a2918befafc51304a3ab89e4cb096b25a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Class to solve the Gross-Pitaevskii equation. </p>
<dl class="section author"><dt>Author</dt><dd>Santo Maria Roccuzzo (<a href="#" onclick="location.href='mai'+'lto:'+'san'+'to'+'m.r'+'oc'+'cuz'+'zo'+'@gm'+'ai'+'l.c'+'om'; return false;">santo<span class="obfuscator">.nosp@m.</span>m.ro<span class="obfuscator">.nosp@m.</span>ccuzz<span class="obfuscator">.nosp@m.</span>o@gm<span class="obfuscator">.nosp@m.</span>ail.c<span class="obfuscator">.nosp@m.</span>om</a>)</dd></dl>
<p>This class allows to solve the Gross-Pitaevskii equation</p>
<p class="formulaDsp">
\[
 i\hbar\frac{\partial \psi}{\partial t} = \left[ \frac{-\hbar^2\nabla^2}{2m}+V_{ext}({\bf r})+g|\psi|^2
\right]\psi
\]
</p>
<p >both for ground-state configurations as well as for the dynamics, on a cartesian mesh with periodic boundary conditions. The basic usage of the class is as follows:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="class_ultra_cold_1_1_g_p_solvers_1_1_g_p_solver.html">GPSolver</a> gp_solver(x,y,z,psi0,Vext,scattering_length);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// for ground state calculations</span></div>
<div class="line"> </div>
<div class="line">std::tie(psi,chemical_potential) = gp_solver.run_gradient_descent(maximum_number_of_iterations,</div>
<div class="line">                                                                  tolerance,</div>
<div class="line">                                                                  alpha,</div>
<div class="line">                                                                  beta,</div>
<div class="line">                                                                  output_stream,</div>
<div class="line">                                                                  write_output_every);</div>
<div class="line"><span class="comment">// or</span></div>
<div class="line"> </div>
<div class="line">gp_solver.run_operator_splitting(number_of_time_steps,</div>
<div class="line">                                 time_step,</div>
<div class="line">                                 output_stream,</div>
<div class="line">                                 write_output_every); <span class="comment">// for the dynamics</span></div>
<div class="ttc" id="aclass_ultra_cold_1_1_g_p_solvers_1_1_g_p_solver_html"><div class="ttname"><a href="class_ultra_cold_1_1_g_p_solvers_1_1_g_p_solver.html">UltraCold::GPSolvers::GPSolver</a></div><div class="ttdoc">Class to solve the Gross-Pitaevskii equation.</div><div class="ttdef"><b>Definition:</b> GPSolvers.hpp:161</div></div>
</div><!-- fragment --><p >In the constructor, you need to provide the (cartesian) axis along which you want to solve the equation (of course, 1, 2 or 3), the initial wave function (all the methods are iterative) and the external potential. All of these must be properly initialized before passing them to the solver class. <br  />
For ground-state calculations, it is possible to generate some output at each step of the gradient-descent iterations. By default, the <a class="el" href="class_ultra_cold_1_1_g_p_solvers_1_1_g_p_solver.html#a84345a4d4b14ccc40bc83b170fea7eff" title="Calculates a ground-state solution to the stationary Gross-Pitaevskii equation.">GPSolver::run_gradient_descent()</a> just writes, in the standard output, the current iteration number, chemical potential and norm of the residual. This default behavior can however be customized by overriding the <a class="el" href="class_ultra_cold_1_1_g_p_solvers_1_1_g_p_solver.html#a622bd85894d716dcabe1778d08e6dad3" title="Write output at each step of the gradient descent iterations.">GPSolver::write_gradient_descent_output()</a> member function. <br  />
A similar behavior is the default also for dynamics calculations, i.e. for the member function <a class="el" href="class_ultra_cold_1_1_g_p_solvers_1_1_g_p_solver.html#a6788cfe66df9122fb9088258a9649862" title="Solve the Gross-Pitaevskii equation using simple operator splitting.">GPSolver::run_operator_splitting()</a>. In this case, the default is just to write the current time step and current time. For examples of usage and customization via overloading, see the example 1 in the <code>examples</code> folder. </p><dl class="section note"><dt>Note</dt><dd>Several member functions of this class take advantage of <a href="https://www.openmp.org/">OpenMP </a> parallelization. For optimal performance, be sure to run <div class="fragment"><div class="line">$ export OMP_NUM_THREADS=&lt;number of physical cores on the machine used&gt;</div>
</div><!-- fragment --> on the shell before the program execution. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The Gross-Pitaevskii equation is solved in its a-dimensional form. In the case of a harmonic potential in one space dimension it has the form</dd></dl>
<p class="formulaDsp">
\[
 i\frac{\partial \psi}{\partial t} = \left[ -\frac{1}{2}\frac{\partial^2}{\partial x^2}+\frac{1}{2}x^2
 +4\pi a|\psi|^2 \right]\psi
\]
</p>
<p> where \( a \) is the scattering length, which here must be given in harmonic units. Be sure to provide the axis, initial wave function, and external potential initialized properly. See the examples in the examples folder. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a27e4ed4915c1e2bfcabb82c2d7d07af0" name="a27e4ed4915c1e2bfcabb82c2d7d07af0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27e4ed4915c1e2bfcabb82c2d7d07af0">&#9670;&nbsp;</a></span>GPSolver() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UltraCold::GPSolvers::GPSolver::GPSolver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ultra_cold_1_1_vector.html">Vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ultra_cold_1_1_vector.html">Vector</a>&lt; std::complex&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>psi_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ultra_cold_1_1_vector.html">Vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>Vext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scattering_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor for a <a class="el" href="class_ultra_cold_1_1_g_p_solvers_1_1_g_p_solver.html" title="Class to solve the Gross-Pitaevskii equation.">GPSolver</a> in one space dimension. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td><em><a class="el" href="class_ultra_cold_1_1_vector.html">Vector&lt;double&gt;</a></em> representing the cartesian axis on which the Gross-Pitaevskii equation in one space dimension will be solved </td></tr>
    <tr><td class="paramname">psi_0</td><td><em><a class="el" href="class_ultra_cold_1_1_vector.html">Vector&lt;std::complex&lt;double&gt;&gt;</a></em> representing the initial wave function </td></tr>
    <tr><td class="paramname">Vext</td><td><em><a class="el" href="class_ultra_cold_1_1_vector.html">Vector&lt;double&gt;</a></em> representing the external potential. </td></tr>
    <tr><td class="paramname">scattering_length</td><td><em>double</em> the scattering length in appropriate units </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a00ae80a9fb6fe441c455ddc7d1b45df5" name="a00ae80a9fb6fe441c455ddc7d1b45df5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00ae80a9fb6fe441c455ddc7d1b45df5">&#9670;&nbsp;</a></span>GPSolver() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UltraCold::GPSolvers::GPSolver::GPSolver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ultra_cold_1_1_vector.html">Vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ultra_cold_1_1_vector.html">Vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ultra_cold_1_1_vector.html">Vector</a>&lt; std::complex&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>psi_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ultra_cold_1_1_vector.html">Vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>Vext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scattering_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor for a <a class="el" href="class_ultra_cold_1_1_g_p_solvers_1_1_g_p_solver.html" title="Class to solve the Gross-Pitaevskii equation.">GPSolver</a> in two space dimensions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td><em><a class="el" href="class_ultra_cold_1_1_vector.html">Vector&lt;double&gt;</a></em> representing the x-axis of the Cartesian frame on which the Gross-Pitaevskii equation in two space dimensions will be solved </td></tr>
    <tr><td class="paramname">y</td><td><em><a class="el" href="class_ultra_cold_1_1_vector.html">Vector&lt;double&gt;</a></em> representing the y-axis of the Cartesian frame on which the Gross-Pitaevskii equation in two space dimensions will be solved </td></tr>
    <tr><td class="paramname">psi_0</td><td><em><a class="el" href="class_ultra_cold_1_1_vector.html">Vector&lt;std::complex&lt;double&gt;&gt;</a></em> representing the initial wave function </td></tr>
    <tr><td class="paramname">Vext</td><td><em><a class="el" href="class_ultra_cold_1_1_vector.html">Vector&lt;double&gt;</a></em> representing the external potential. </td></tr>
    <tr><td class="paramname">scattering_length</td><td><em>double</em> the scattering length in appropriate units </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada67b8cb4973130f71e25058f4225791" name="ada67b8cb4973130f71e25058f4225791"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada67b8cb4973130f71e25058f4225791">&#9670;&nbsp;</a></span>GPSolver() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UltraCold::GPSolvers::GPSolver::GPSolver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ultra_cold_1_1_vector.html">Vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ultra_cold_1_1_vector.html">Vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ultra_cold_1_1_vector.html">Vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ultra_cold_1_1_vector.html">Vector</a>&lt; std::complex&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>psi_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ultra_cold_1_1_vector.html">Vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>Vext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scattering_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor for a <a class="el" href="class_ultra_cold_1_1_g_p_solvers_1_1_g_p_solver.html" title="Class to solve the Gross-Pitaevskii equation.">GPSolver</a> in three space dimensions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td><em><a class="el" href="class_ultra_cold_1_1_vector.html">Vector&lt;double&gt;</a></em> representing the x-axis of the Cartesian frame on which the Gross-Pitaevskii equation in two space dimensions will be solved </td></tr>
    <tr><td class="paramname">y</td><td><em><a class="el" href="class_ultra_cold_1_1_vector.html">Vector&lt;double&gt;</a></em> representing the y-axis of the Cartesian frame on which the Gross-Pitaevskii equation in two space dimensions will be solved </td></tr>
    <tr><td class="paramname">z</td><td><em><a class="el" href="class_ultra_cold_1_1_vector.html">Vector&lt;double&gt;</a></em> representing the z-axis of the Cartesian frame on which the Gross-Pitaevskii equation in two space dimensions will be solved </td></tr>
    <tr><td class="paramname">psi_0</td><td><em><a class="el" href="class_ultra_cold_1_1_vector.html">Vector&lt;std::complex&lt;double&gt;&gt;</a></em> representing the initial wave function </td></tr>
    <tr><td class="paramname">Vext</td><td><em><a class="el" href="class_ultra_cold_1_1_vector.html">Vector&lt;double&gt;</a></em> representing the external potential. </td></tr>
    <tr><td class="paramname">scattering_length</td><td><em>double</em> the scattering length in appropriate units </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a25266cb9ac54c8d7faed86fc2eb987b4" name="a25266cb9ac54c8d7faed86fc2eb987b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25266cb9ac54c8d7faed86fc2eb987b4">&#9670;&nbsp;</a></span>reinit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UltraCold::GPSolvers::GPSolver::reinit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ultra_cold_1_1_vector.html">Vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>Vext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ultra_cold_1_1_vector.html">Vector</a>&lt; std::complex&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>psi_0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reinitialize the solver with new external potential and initial condition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Vext</td><td><em><a class="el" href="class_ultra_cold_1_1_vector.html">Vector&lt;double&gt;</a></em> the new external potential. </td></tr>
    <tr><td class="paramname">psi_0</td><td><em><a class="el" href="class_ultra_cold_1_1_vector.html">Vector&lt;std::complex&lt;double&gt;&gt;</a></em> the new initial wave function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This function does not perform any bound check, hence you must be careful to pass Vectors with the same dimensionality and extents as those passed to the constructor. </dd></dl>

</div>
</div>
<a id="aa52ead6af5a33d5bd9d3ad75ef66763b" name="aa52ead6af5a33d5bd9d3ad75ef66763b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa52ead6af5a33d5bd9d3ad75ef66763b">&#9670;&nbsp;</a></span>reinit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UltraCold::GPSolvers::GPSolver::reinit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ultra_cold_1_1_vector.html">Vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>Vext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ultra_cold_1_1_vector.html">Vector</a>&lt; std::complex&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>psi_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scattering_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reinitialize the solver with new external potential and initial condition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Vext</td><td><em><a class="el" href="class_ultra_cold_1_1_vector.html">Vector&lt;double&gt;</a></em> the new external potential. </td></tr>
    <tr><td class="paramname">psi_0</td><td><em><a class="el" href="class_ultra_cold_1_1_vector.html">Vector&lt;std::complex&lt;double&gt;&gt;</a></em> the new initial wave function. </td></tr>
    <tr><td class="paramname">scattering_length</td><td><em>double</em> the new initial scattering length</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This function does not perform any bound check, hence you must be careful to pass Vectors with the same dimensionality and extents as those passed to the constructor. </dd></dl>

</div>
</div>
<a id="a84345a4d4b14ccc40bc83b170fea7eff" name="a84345a4d4b14ccc40bc83b170fea7eff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84345a4d4b14ccc40bc83b170fea7eff">&#9670;&nbsp;</a></span>run_gradient_descent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; <a class="el" href="class_ultra_cold_1_1_vector.html">Vector</a>&lt; std::complex&lt; double &gt; &gt;, double &gt; UltraCold::GPSolvers::GPSolver::run_gradient_descent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>max_num_iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>output_stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>write_output_every</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates a ground-state solution to the stationary Gross-Pitaevskii equation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_num_iter</td><td><em>int</em> the maximum number of gradient descent iterations </td></tr>
    <tr><td class="paramname">tolerance</td><td><em>double</em> the maximum norm of the residual, below which the algorithm is considered as converged </td></tr>
    <tr><td class="paramname">alpha</td><td><em>double</em> the step-length of the gradient-descent iterations. </td></tr>
    <tr><td class="paramname">beta</td><td><em>double</em> acceleration step for the heavy-ball method. </td></tr>
    <tr><td class="paramname">output_stream</td><td><em>std::ostream</em> stream to which eventual text output can be passed </td></tr>
    <tr><td class="paramname">write_output_every</td><td><em>int</em> number of iterations after which some output must be written</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::tuple&lt;<a class="el" href="class_ultra_cold_1_1_vector.html">Vector&lt;std::complex&lt;double&gt;&gt;</a>,double&gt; representing the calculated ground-state wave function and chemical potential. Can be recovered by using std::tie(psi,chemical_potential).</dd></dl>
<p>The Gross-Pitaevskii equation allows to obtain information on the ground-state properties of an ultra-cold bosonic system by searching for stationary solutions of the form \( \psi({\bf r},t)=\psi_0({\bf r})e^{-i\mu t/\hbar} \), obtaining the stationary Gross-Pitaevskii equation </p><p class="formulaDsp">
\[
\mu \psi_0 = \left[ \frac{-\hbar^2\nabla^2}{2m}+V_{ext}({\bf r})+ g|\psi_0|^2 \right]\psi_0
\]
</p>
<p> where \( g \) is related to the s-wave scattering length \( a \) by \( g=\frac{4\pi\hbar^2 a}{2m} \). Solving this for the smallest eigenvalue \( \mu \), which represents the chemical potential, gives access to the ground-state configuration of the system. <br  />
In order to solve this equation, one can notice that it can be obtained from a constrained minimization formulation of the problem, in particular by requiring that the ground-state order parameter of the system is the exact minimizer of the mean-field energy functional </p><p class="formulaDsp">
\[
E[\psi] = \int d{\bf r} \left[ \psi^*({\bf r})\left(\frac{-\hbar^2\nabla^2}{2m}+
V_{ext}({\bf r})\right)\psi({\bf r}) \right] +\frac{g}{2}\int d{\bf r} |\psi({\bf r})|^4
\]
</p>
<p> under the constraint of a fixed number of particles \( \int d{\bf r}|\psi({\bf r})|^2=N \). This allows also to introduce the chemical potential \( \mu \) as the Lagrange multiplier fixing the total number of particles. One can hence find the ground state order parameter and chemical potential using, for example, a <a href="https://en.wikipedia.org/wiki/Gradient_descent">gradient descent </a> method, which is the one implemented in this function. <br  />
The idea is to start from a guess solution \(\psi_0\) and generate a sequence of iterates \( \{\psi_n\}_{\{n=0,...,\infty\}} \) that terminates when one is sufficiently confident to have reached a (hopefully global) minimizer of the mean-field energy functional with good accuracy. In particular, a good stopping criterion consists in fixing a tolerance threshold \(\epsilon\) (which, for this function, is a user-defined input parameter) for the norm of the residual, i.e. \( || \hat{H}\psi_n  \mu_n \psi_n ||^2 \leq \epsilon \), where \(\hat{H}\) is the mean-field Hamiltonian of the system and the estimate \( \mu_n \) of the chemical potential \( \mu \) at iteration \( n \) can be calculated as \( \mu_n = \langle \psi_n | \hat{H} | \psi_n \rangle /  \langle \psi_n | \psi_n \rangle \). <br  />
In deciding how to move from one iterate \( \psi_n \) to the next \( \psi_{n+1} \), line search algorithms like the gradient descent method use information about the functional \( E[\psi] \) at \( \psi_n \), and possibly also from earlier iterates \( \psi_0, \psi_1, \dots, \psi_{n-1} \). The update criterion should be that the energy functional is smaller in \( \psi_{n+1} \) then in \( \psi_n \). One thus generates a sequence \( \psi_{n+1} = \psi_n + \alpha \chi_n \) such that \( E[\psi_{n+1}]
&lt; E[\psi_n] &lt; \dots &lt; E[ \psi_0 ] \) until the stopping criterion is satisfied. The update direction \( \chi_n \) must thus be chosen to be a descent direction, i.e. a direction along which the functional \( E[\psi] \) decreases. The step-length \( \alpha \) should instead be (ideally) chosen in such a way that the decrease in the energy functional is, at each iteration step, the maximum possible. Since this is not, in general, an easy task, in this function we accept the compromise to choose the step length \( \alpha \) empirically as an input parameter at the beginning of the iteration procedure. This also implies that the user may need to run the function a few times before finding an optimal value for \( \alpha \). <br  />
Coming back to the choice of \( \chi_n \), the gradient descent method consists in choosing such descent direction as the opposite of the gradient of the functional \( E[\psi] \) calculated in \( \psi_n \) . So, in this case, the descent direction is (minus) the functional derivative of the energy functional with respect to \( \psi^* \) evaluated at \( \psi_n \) , i.e. </p><p class="formulaDsp">
\[

\chi_n = - \frac{\delta E[\psi_n]}{\delta \psi^*} =
- \left[ \frac{-\hbar^2\nabla^2}{2m}+V_{ext}({\bf r})+g|\psi_n|^2 \right] \psi_n

\]
</p>
<p> The ground state wave function obtained from this algorithm is normalized in such a way to preserve the initial norm, i.e. the norm of the initial wave function provided. Such normalization condition, fixing the \( L^2 \) norm of the ground-state wave-function \( \psi \) should be included in the iteration procedure by introducing a Lagrange multiplier and minimizing the corresponding lagrangian functional. In practice, it is much cheaper to normalize by hand each \( \psi_n \) obtained via the gradient descent iteration, by fixing </p><p class="formulaDsp">
\[
 \psi_{n+1}^{(1)} = \psi_n + \alpha \chi_n
\]
</p>
 <p class="formulaDsp">
\[
\psi_{n+1} = \sqrt{\frac{N}{\int d{\bf r}|\psi_{n+1}^{(1)}|^2}}\psi_{n+1}^{(1)}
\]
</p>
<p> where \( N \) is the initial norm. Notice that, physically, this represents the total number of particles in the system, and as such must be an integer. Hence, the initial wave function must be properly normalized before the gradient-descent iterations start. <br  />
Finally, this function employs an acceleration algorithm, known as the <a href="https://www.worldscientific.com/doi/abs/10.1142/S0219199700000025">heavy ball method </a>, in order to speed up the convergence of the sequence \( {\psi_n} \). The method consists in adding a momentum term into the gradient-descent iterations, in order to make larger steps if the descent direction does not change very much, and smaller steps if it changes a lot. In practice, what one does is just to modify the gradient-descent expression in \( \psi_{n+1} = \psi_n + \alpha \chi_n + \beta(\psi_n-\psi_{n-1}) \) where, again, \( \beta \) is a parameter chosen empirically and given to this function as input. </p>

</div>
</div>
<a id="a6788cfe66df9122fb9088258a9649862" name="a6788cfe66df9122fb9088258a9649862"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6788cfe66df9122fb9088258a9649862">&#9670;&nbsp;</a></span>run_operator_splitting()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void UltraCold::GPSolvers::GPSolver::run_operator_splitting </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>number_of_time_steps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>output_stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>write_output_every</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solve the Gross-Pitaevskii equation using simple operator splitting. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">number_of_time_steps</td><td><em>int</em> The total number of time-steps to be performed </td></tr>
    <tr><td class="paramname">time_step</td><td><em>double</em> time step in appropriate units </td></tr>
    <tr><td class="paramname">output_stream</td><td><em>std::ostream</em> stream to which eventual text output can be passed</td></tr>
  </table>
  </dd>
</dl>
<p>This member function solves the (a-dimensional) time-dependent Gross-Pitaevskii equation </p><p class="formulaDsp">
\[
i \frac{\partial \psi}{\partial t} = \left[ \frac{-\nabla^2}{2}+V_{ext}({\bf r})+g|\psi|^2 \right]\psi
\]
</p>
<p> using the classic operator splitting technique.<br  />
The general idea of operator-splitting methods is to consider an initial value problem </p><p class="formulaDsp">
\[
y&#39; = \text{A} y + \text{B} y
\]
</p>
<p> where \( A \) and \( B \) are differential operators, and solve the equation considering the actions of the two operators separately. There is a vast literature on operator-splitting approaches for the solution of differential equations, and different methods with a higher or lower level of accuracy. In the case of the Gross-Pitaevskii equation, things are even more simplified by the fact that part of the method implies steps that can be solved <em>exactly</em>. <br  />
After choosing a time-step \( \Delta t \), the operator spltting scheme consists in the following steps </p><p class="formulaDsp">
\[
\begin{align}
&amp; \text{For}   \quad n=0,1,\dots,\text{number_of_time_steps} \nonumber \\
&amp; \text{Step 1: solve} \quad y&#39;_1 = \text{A}y_1 \quad \text{in} \quad [t_n,t_n+\Delta t]
\quad \text{for} \quad y_1(0)=y(t_n) \nonumber \\
&amp; \text{Step 2: solve} \quad y&#39;_2 = \text{B}y_2 \quad \text{in} \quad [t_n,t_n+\Delta t]
\quad \text{for} \quad y_2(0)=y_1(t_n+\Delta t) \nonumber \\
&amp; \text{Set} \quad y(t_{n+1}) = y_2(t_n+\Delta t) \nonumber \\
\end{align}
\]
</p>
<p> The steps imply the solution of an ordinary differential equation. In the case of the Gross-Pitaevskii equation, a good choice of the operators \( A \) and \( B \) is the following </p><p class="formulaDsp">
\[
\begin{align}
 &amp; A = V_{ext} + g |\psi(t)|^2 \nonumber \\
 &amp; B = \frac{-\nabla^2}{2} \nonumber \\
\end{align}
\]
</p>
<p >In this case, step 1, although involve the solution of a non-linear differential equation, can be solved <b>analytically</b>. In fact, it is easy to show that the equation </p><p class="formulaDsp">
\[
 i\frac{d}{dt}\psi(t) = V_{ext} + g |\psi(t)|^2
\]
</p>
<p> preserves the norm \( \psi \) in time, and hence an explicit solution of this equation is </p><p class="formulaDsp">
\[
\psi(t+\Delta t) = e^{-i\Delta t\left( V_{ext} + g |\psi(t)|^2 \right)}\psi(t)
\]
</p>
<p> Moreover, also the second step of the method can be solved analytically, provided that one imposes <em>periodic boundary conditions</em>. In fact, given the equation </p><p class="formulaDsp">
\[
i\frac{d}{dt}\psi(t) = \frac{-\nabla^2}{2}\psi(t)
\]
</p>
<p> and taking the Fourier transform (in space) at both sides, one finds </p><p class="formulaDsp">
\[
i\frac{d}{dt}\tilde{\psi}(t) = \frac{k^2}{2}\tilde{\psi}(t)
\]
</p>
<p> which can again be solved exactly as </p><p class="formulaDsp">
\[
\tilde{\psi}(t+\Delta t) = e^{-i\Delta t\frac{k^2}{2}}\tilde{\psi}(t)
\]
</p>
<p> Finally, an inverse Fourier transform allows to recover the solution back in real space, ready to take another time step. <br  />
To summarize, this member function solves the Gross-Pitaevskii equation using classic operator splitting via the following steps</p><ul>
<li>Step 1) Set \( \psi(t_n + \Delta t) =
 e^{-i\Delta t\left( V_{ext} + g |\psi(t_n)|^2 \right)}\psi(t_n) \);</li>
<li>Step 2)<ul>
<li>2.1) Take the Fourier transform of \( \psi(t_n + \Delta t) \), and call it \( \tilde{\psi}(t_n) \);</li>
<li>2.2) Set \( \tilde{\psi}(t_n+\Delta t) = e^{-i\Delta t\frac{k^2}{2}}\tilde{\psi}(t_n) \)</li>
<li>2.3) Take the inverse Fourier transform of \( \tilde{\psi}(t_n+\Delta t) \), and obtain \( \psi(t_n+\Delta t) \)</li>
</ul>
</li>
</ul>
<p >Notice that all these steps can be computed <em>locally</em>, meaning that we don't need additional vectors to store intermediate values of \( \psi \). </p>

</div>
</div>
<a id="a52ef3dbf3041aa314cf61f24e086129a" name="a52ef3dbf3041aa314cf61f24e086129a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52ef3dbf3041aa314cf61f24e086129a">&#9670;&nbsp;</a></span>set_tw_initial_conditions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UltraCold::GPSolvers::GPSolver::set_tw_initial_conditions </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>system_is_trapped</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>first_call</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>number_of_modes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set initial conditions for a run in the context of the Truncated Wigner Approximation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">system_is_in_harmonic_trap</td><td><em>bool</em> specify whether the system is confined in a harmonic trap or not </td></tr>
    <tr><td class="paramname">first_call</td><td><em>bool</em> specify if this is the first call to the function or not. If <em>true</em>, it will calculate a base of eigenstates of the single-particle hamiltonian, otherwise it will assume that such eigenstates have been already calculated in a previous call to the function. </td></tr>
    <tr><td class="paramname">number_of_modes</td><td><em>int</em> the number of single-particle modes to be added to the ground state wave function</td></tr>
  </table>
  </dd>
</dl>
<p>When the temperature of a BEC is very close to the absolute zero, the simulation of the dynamics of the system can be improved by properly taking into account the effects of quantum fluctuations on the initial conditions for the dynamics. The Truncated Wigner Approximation (TWA) allows to simulate such effects using so-called <em>c-field</em> techniques.</p>
<p >A general introduction to the topic can be found in &lt;href="https://arxiv.org/pdf/0809.1487.pdf"&gt; this review . Here we just sketch the main ideas that lie behind the implementation of this class,</p>
<p >The fundamental idea of all c-field methods is to divide the energy spectrum of the system into a <em>c-field</em> region (often called coherent region), in which the dynamics of the low-energy, highly occupied modes can be simulated by means of <b>classical</b> stochastic field equations (in our case, a simple Gross-Pitaevskii equation), and an <em>incoherent</em> region, consisting of the remaining, higher energy modes, which will be sparsely occupied because of thermal or vacuum excitations.</p>
<p >The Truncated Wigner Approximation can be applied in the case in which we have several modes with a high occupation in the c-field region, while many higher modes in the c-field region, as well as all the modes of the incoherent region, are unoccupied.</p>
<p >In these conditions, the quantum fluctuations in the c-field region have a significant effect, and this is taken into account by including a random element corresponding to <b>half</b> a quantum occupation in each mode in the initial conditions. This is needed in order to appropriately sample the Wigner quasi-probability distribution. The successive dynamics is instead well described by the ordinary GPE.</p>
<p >This function is supposed to be called right after a run of the member class <code><a class="el" href="class_ultra_cold_1_1_g_p_solvers_1_1_g_p_solver.html#a84345a4d4b14ccc40bc83b170fea7eff" title="Calculates a ground-state solution to the stationary Gross-Pitaevskii equation.">run_gradient_descent()</a></code>, or at least in a condition in which the wave function has been re-initialized to the ground state of the system via a call to the member function <code>reinit</code>. In fact, calling \( \psi_0 \) the wave function currently known by the class, this function will transform it in the coherent field \( \psi_c({\bf r}) = \psi_0({\bf r}) + \sum_{n} c_n\phi_n({\bf r}) \), where</p><ul>
<li>\( c_n \) are independent randomly distributed <em>complex</em> Gaussian variables, with zero mean and variance equal to \( \frac{1}{2} \)</li>
<li>if the member logical variable <code>system_is_in_harmonic_trap</code> is true, \( \psi_n \) are the eigenstates of the single-particle Hamiltonian of the system.</li>
</ul>
<p >After this is done, one can run a new simulation by calling the member function <code>run_operator_splitting</code> to generate a new trajectory and calculate the desired ensemble averages of observables of interest. * </p>

</div>
</div>
<a id="af5723859b9d1ab0b9b1bd10a861fd56d" name="af5723859b9d1ab0b9b1bd10a861fd56d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5723859b9d1ab0b9b1bd10a861fd56d">&#9670;&nbsp;</a></span>solve_step_1_operator_splitting()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void UltraCold::GPSolvers::GPSolver::solve_step_1_operator_splitting </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Useful possible overload. </p>

<p>Reimplemented in <a class="el" href="classmy_g_p_solver.html#a716e17b93e47406b7cbe2bc2d258fe17">myGPSolver</a>.</p>

</div>
</div>
<a id="a622bd85894d716dcabe1778d08e6dad3" name="a622bd85894d716dcabe1778d08e6dad3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a622bd85894d716dcabe1778d08e6dad3">&#9670;&nbsp;</a></span>write_gradient_descent_output()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void UltraCold::GPSolvers::GPSolver::write_gradient_descent_output </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>iteration_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>output_stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write output at each step of the gradient descent iterations. </p>
<p >This function can (and should) be overridden in derived classes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iteration_number</td><td><em>size_t</em> current iteration number </td></tr>
    <tr><td class="paramname">output_stream</td><td><em>std::ostream</em> stream to which eventual text output can be passed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Writing output data files at each gradient descent step may be useful, but it is also very expensive. Override this member function with care! </dd></dl>

</div>
</div>
<a id="ac55d1c9f9408d67cac7da7c5b734519a" name="ac55d1c9f9408d67cac7da7c5b734519a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac55d1c9f9408d67cac7da7c5b734519a">&#9670;&nbsp;</a></span>write_operator_splitting_output() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void UltraCold::GPSolvers::GPSolver::write_operator_splitting_output </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>iteration_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>output_stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write some output at each time step. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iteration_number</td><td><em>size_t</em> current iteration number </td></tr>
    <tr><td class="paramname">output_stream</td><td><em>std::ostream</em> stream to which eventual text output can be passed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5fead0fe846e939e6de4a5807f604796" name="a5fead0fe846e939e6de4a5807f604796"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fead0fe846e939e6de4a5807f604796">&#9670;&nbsp;</a></span>write_operator_splitting_output() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void UltraCold::GPSolvers::GPSolver::write_operator_splitting_output </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Useful possible overload. </p>

<p>Reimplemented in <a class="el" href="classmy_g_p_solver.html#ad6c9b6b574baa6241531383bddecf1e5">myGPSolver</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_ultra_cold.html">UltraCold</a></li><li class="navelem"><a class="el" href="namespace_ultra_cold_1_1_g_p_solvers.html">GPSolvers</a></li><li class="navelem"><a class="el" href="class_ultra_cold_1_1_g_p_solvers_1_1_g_p_solver.html">GPSolver</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
